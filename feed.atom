<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title>CBojar.net</title>
	<id>https://cbojar.net/feed.atom</id>
	<link href="https://cbojar.net/"/>
	<link rel="self" href="https://cbojar.net/feed.atom"/>
	<updated>2022-03-03T14:00:17-07:00</updated>
	<entry>
		<id>https://medium.com/p/7ac8dae6ef33</id>
		<title>Sprints Aren’t Commitments</title>
		<link rel="alternate" type="text/html" href="https://medium.com/ready-for-dev/sprints-arent-commitments-7ac8dae6ef33?source=rss-3fc109936724------2"/>
		<published>2021-06-04T15:20:44Z</published>
		<updated>2021-06-04T15:20:44Z</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<div class="medium-feed-item"><p class="medium-feed-image"><a href="https://medium.com/ready-for-dev/sprints-arent-commitments-7ac8dae6ef33?source=rss-3fc109936724------2"><img src="https://cdn-images-1.medium.com/max/2600/0*SY3EoHqHASkMXQgg" width="3600"></a></p><p class="medium-feed-snippet">Pretending they are only hurts us</p><p class="medium-feed-link"><a href="https://medium.com/ready-for-dev/sprints-arent-commitments-7ac8dae6ef33?source=rss-3fc109936724------2">Continue reading on Ready for Dev »</a></p></div>]]></content>
	</entry>
	<entry>
		<id>https://medium.com/p/461eaa4ec5e5</id>
		<title>Deceptive Quantification</title>
		<link rel="alternate" type="text/html" href="https://medium.com/ready-for-dev/deceptive-quantification-461eaa4ec5e5?source=rss-3fc109936724------2"/>
		<published>2021-01-22T16:29:53Z</published>
		<updated>2021-01-22T16:29:53Z</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<div class="medium-feed-item"><p class="medium-feed-image"><a href="https://medium.com/ready-for-dev/deceptive-quantification-461eaa4ec5e5?source=rss-3fc109936724------2"><img src="https://cdn-images-1.medium.com/max/2600/0*yq8Csn46SVLoMAmO" width="5060"></a></p><p class="medium-feed-snippet">When numbers aren&#x2019;t really numbers</p><p class="medium-feed-link"><a href="https://medium.com/ready-for-dev/deceptive-quantification-461eaa4ec5e5?source=rss-3fc109936724------2">Continue reading on Ready for Dev »</a></p></div>]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-1030960230531520542</id>
		<title>The Timeline of Errors</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2021/01/the-timeline-of-errors.html"/>
		<published>2021-01-21T11:10:00-05:00</published>
		<updated>2021-01-21T11:10:33-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<p>  As software developers, we see errors every day. They manifest as exceptions or segfaults or error codes, telling us that our code has gotten into a state we didn't expect. Their appearance often portends bugs. Though we groan at an unexpected stack trace, we should see an error as a form of <em>automated feedback</em>. Feedback can be fast or slow. We can put the discovery of errors onto a timeline. </p> <figure>  <img alt="A timeline of errors. From left to right: Compile time, Runtime, Use time, Log time, Ignore time" border="0" data-original-height="144" data-original-width="816" src="https://1.bp.blogspot.com/-AeFVEBg-GgQ/YAYE1cFFZPI/AAAAAAAABRs/G3f0SJ5yHTU8OtCR06_vLukc21Xjde1JACLcBGAsYHQ/s0/timeline%2Bof%2Berrors.png"/></figure> <p>  Errors appear at many points over the lifetime of the code, starting at the moment it is compiled. The further to the right that an error appears, the longer it takes for the feedback to appear. </p> <h1>Compile time</h1> <p>  Compile time is the earliest we can receive feedback about an error. The compiler automatically does a number of checks to make sure the code makes some semblance of sense. The most powerful tool for compile-time feedback is the type-checker. The type-checker makes sure that only values of the expected type are passed around to the places that expect them. This guards our code from trying to handle, say, a string of text when it expects a number. We can also leverage the type system with small types to verify higher level logic. Not all languages have a compiler, or support static typing. These languages lose the benefits from a compilation step, but can regain some by using static analysis, linting, and type hints. </p> <p>  Compile time error detection is powerful because of how quickly we get the feedback. The code doesn't even get committed. No customer will ever see the error. Not even other teammates will see it. An IDE that automatically compiles code saves the step of actually running the compiler, giving this feedback right in the editor. </p> <h1>Runtime</h1> <p>  Many errors are found when the code runs. I lump in automated testing with runtime, since we see the errors by actually running the code. Good runtime errors will tell you exactly what happened where. Bad ones will be more mysterious. Runtime errors come from bad code. There's a case we didn't expect, or a value we didn't handle. Since the code has gotten into a bad state, a runtime error is the best way to get out without breaking things more. It is futile to call a method on a null value, for example, and the code shouldn't try to continue. </p> <p>  Runtime errors take longer to appear than compile time errors. They aren't guaranteed to happen at all. A special, unhandled case may not occur for years. Or a special case may only become possible due to a change in another part of the code. However, when they do happen, the feedback is immediate from that moment. Because of the certain uncertainty of runtime errors, many frameworks and applications have built-in ways of safely handling and reporting them. </p> <h1>Use time</h1> <p>  Not all errors nicely present as compile or runtime errors. Many errors happen at the time of use, and are only detected by users as invalid data or broken functionality. These errors happen because the code gets into a bad state, but continues anyway. Use time errors can lead to data corruption and loss of functionality. A form failing to load and only showing a blank screen is a use time error. An update to a shipping speed not getting saved is a use time error. A transaction that deducts from one account but does not add to the other is a use time error. </p> <p>  Use time errors can be caught by exhaustive manual testing. Just as often, and more embarrassingly, they are caught by end users. Worse, because use time errors have made it all the way to production, it can be difficult to trace back to the original change that caused the problem. Use time errors are often latent. The error may not appear where the problem lives. Rather, it causes another error, like a runtime error, in a different, seemingly unrelated part of the code. Because of this, I think of them as little ticking time bombs waiting to explode at just the wrong time. </p> <h1>Log time</h1> <p>  Even end users won't detect every error, despite their best efforts. Sometimes we write code that is so good at hiding its faults that we can only detect indescretions by reading log messages. I know no developer that spends their weekends gleefully reading application debug logs. I know plenty that have buried important indicators in those logs. If an error is logged at a sufficiently high level, it might get noticed by monitoring software and bubbled up to the development team. Since there is no standard for what constitutes an error versus a warning versus info, we can't rely on this happening. </p> <p>  Unless we are willing to stare at a screen of scrolling log messages every minute of the day, we must rely on automated monitoring to detect log time errors. More often, log time errors are found forensically once an issue is discovered via a different route. At that point, we hope they are sufficient to reconstruct the invalid state. </p> <h1>Ignore time</h1> <p>  Sometimes, we hide errors so well, we don't even know they are happening. We've ignored any way to give an indication that something is wrong. This is the most dangerous situation. Errors happen, nothing tells us, and we can't figure out what happened after the fact. We should never be consciously ignoring an error. </p> <h1>Find errors better by finding them earlier</h1> <p>  The longer our feedback cycles, the more costly it is to fix a defect that an error exposes. Therefore, we should strive to move our errors as far to the left as we can. This way, we will see them earlier and fix them faster. For example, dereferencing a null pointer is a runtime error. We can move this to a compile time error by using optional or nullable types. Then, the compiler will complain to us if we don't handle the missing value. We can move log time errors earlier by having the user confirm the output, or by automatically verifying the expected end state. We get feedback for each of these kinds of errors that much faster. </p> <p>  As we want to move errors to the left, there is a natural entropy that pushes them back to the right. Using the example of replacing null values with optionals, we could do <code>optionalValue.get()</code> in Java. The compiler made sure we handled the missing value, but the way we handled it moved it back into the realm of runtime errors. This tension will always exist, so we must be diligent to keep errors where we want them on the timeline. </p>]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-4250527858604815329</id>
		<title>The Cone of Code Uncertainty</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2020/12/the-cone-of-code-uncertainty.html"/>
		<published>2020-12-31T10:00:00-05:00</published>
		<updated>2020-12-31T10:00:03-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<p>  As hurricanes approach the shores of North America, we are barraged with maps of possible tracks those storms can take. Those tracks start pretty close together, but diverge widely the further into the future they predict. Simplified, those storm tracks form a <a href="https://en.wikipedia.org/wiki/Cone_of_Uncertainty" target="_blank">cone of uncertainty</a>. A storm in the Atlantic could slide into the Gulf of Mexico and land anywhere from the Texas-Mexico border to Panama City Beach, FL. It all depends on a myriad of tiny factors to turn the storm this way or that. As time progresses, the storm moves along, and the cone of uncertainty shrinks. Its eventual location becomes clearer to predict, and we can more effectively target resources. </p> <figure>  <div class="separator" style="clear: both;"><img alt="" border="0" data-original-height="716" data-original-width="895" src="https://1.bp.blogspot.com/-lMSmVuoHKX8/X9PhiR2QA9I/AAAAAAAABQc/-DzE-bwhf3czQhpXG8hQ7FbX81vpSO-dQCLcBGAsYHQ/s0/Hurricane_Ike_-_Forecast_Plot_-_Sept._9%252C_2008_%25282842229371%2529.gif"/></div>  <figcaption><small>Cone of Uncertainty for Hurricane Ike, <a href="https://commons.wikimedia.org/wiki/File:Hurricane_Ike_-_Forecast_Plot_-_Sept._9,_2008_(2842229371).gif" target="_blank">source</a></small></figcaption></figure> <p>  Much like hurricanes, running code lives in a cone of uncertainty. A function or method call is a mysterious black box until we have a result. If something goes wrong, we must delve into this cone of code uncertainty to find the problem. We use log statements and debuggers and a whole lot of time. We parse through to find where the code diverges from the assumptions in our mental model. Eventually we find the problem, fix it, and breathe a sigh of relief. </p> <p>  Sometimes we only need to dig in a little bit, find the problem, and fix it. Other times, we have to dig down into very large functions with lots of nested calls and complex conditional logic. The latter have a much larger cone of uncertainty. Until we get all the way down, we don't really know where the problem could be. Bugs are especially hard to find when they manifest in a generic block of code, but the real problem is somewhere three layers up from that. </p> <p>  Often it seems like this is just how software development is. But it doesn't have to be. If we understand that we have this cone of uncertainty, we can focus on shrinking it down as much as we can. </p> <p>  How can we reduce the uncertainty in our code? This uncertainty starts when we call a function or method in our code. That function is a black box to the caller. It can't know what is happening until a result or an error is returned. That function can call other functions, call out to external resources, and just be generally complicated. We can reduce the uncertainty by shrinking the amount of code in a function, reducing the call depth within that function, and enforcing strong invariants around that function.  </p> <p>  To accomplish these characteristics is straightforward, though occasionally tedious. First, if there is a lot of code in a function or method, decompose that function into smaller functions. This doesn't reduce the <em>amount</em> of code, but it does clarify and isolate the chunks of logic within it. Once the function has been decomposed, we can look at whether each sub-call should actually be done in that method, or whether we can pull that code out to the caller and reduce the call depth. Separating function calls to run consecutively creates boundaries. We can make clearer assertions on the intermediate values, enforcing stronger invariants on and between the calls. Once we have these smaller, more understandable chunks of code, we can validate our assumptions around them, fixing the inconsistencies that lead to bugs. </p>]]></content>
	</entry>
	<entry>
		<id>https://medium.com/p/2c93251b384b</id>
		<title>Pull the Andon Cord!</title>
		<link rel="alternate" type="text/html" href="https://medium.com/ready-for-dev/pull-the-andon-cord-2c93251b384b?source=rss-3fc109936724------2"/>
		<published>2020-12-18T15:52:01Z</published>
		<updated>2020-12-18T15:52:01Z</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<div class="medium-feed-item"><p class="medium-feed-image"><a href="https://medium.com/ready-for-dev/pull-the-andon-cord-2c93251b384b?source=rss-3fc109936724------2"><img src="https://cdn-images-1.medium.com/max/2600/0*0ulRb4fhT1MzEVH6" width="5472"></a></p><p class="medium-feed-snippet">You should use it more than you do</p><p class="medium-feed-link"><a href="https://medium.com/ready-for-dev/pull-the-andon-cord-2c93251b384b?source=rss-3fc109936724------2">Continue reading on Ready for Dev »</a></p></div>]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-6991310087723462096</id>
		<title>Assuming Maintainability</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2020/12/assuming-maintainability.html"/>
		<published>2020-12-17T11:00:00-05:00</published>
		<updated>2020-12-17T11:00:05-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<blockquote>  <p>    Bugs are bad assumptions. Making assumptions explicit leads to more direct, easier to maintain code.   </p></blockquote> <p>	<a href="TODO">Bugs are bad assumptions.</a> Therefore, to reduce bugs and make code more maintainable, we need to make our assumptions as explicit as we can. We make our assumptions explicit in five ways: comments, tests, conditionals, assertions, and encapsulation with the type system. Each of these ways gives us progressively more assurance that our explicit assumptions are enforced in the code base. They also give us progressively earlier feedback when our code fails to live up to our assumptions. </p> <h1>Comments</h1><p>  Comments are the simplest way to express an assumption in the code. We write out, in plain language, what our assumption is. We can then read those assumptions quickly when need to use that piece of code. For example, we can state assumptions in method-level comments that describe our parameters.  </p> <pre><code><br />/**<br /> * Divide the dividend by the divisor.<br /> * @param dividend the number to divide into<br /> * @param divisor the number to divide by; <strong>must not be zero</strong><br /> */<br />public static double divide(final double dividend, final double divisor) {<br />    return dividend / divisor;<br />}<br /></code></pre> <p>  Here we declare in our comment that passing a zero divisor is not acceptable. When we go to call this method, we can see from the documentation that we should make sure we don't pass in a zero value. The downside to a comment is that there is nothing that really enforces it. If we do pass in a zero value, the JVM will throw an <code>ArithmeticException</code> that will propagate out of this method, up the call stack. Other languages may be less forgiving. Instead, undefined behavior could result in an unexpected value, or a program-crashing fault. There are stronger ways to declare our above assumption, but sometimes there is logic that cannot be expressed elegantly in code. For those cases, we must rely on comments and the diligence of our fellow developers. Even when we can enforce our assumptions through stronger strategies, it is often still valuable to add the comments. </p> <h1>Tests</h1><p>  Ideally, we would like to express our assumptions in an executable format. If our explicit assumptions are executable, we can know if those assumptions are truly valid, and if those assumptions change as we change our code. This is an advantage that comments don't have. We can write a trivial test for the <code>divide</code> method above to express our assumption. </p> <pre><code><br />@Test(expected = ArithmeticException.class)<br />public void shouldNotAllowDivisionByZero() {<br />    divide(1.0, 0.0);<br />}<br /></code></pre> <p>  Writing tests is a good practice in general. We can consider all tests, by definition, to be an explicit expression of assumptions under given conditions. We are always testing that, given a certain set of circumstances, we assume the code to respond in a certain way. Fast, focused tests give us fast, focused feedback. </p> <p>  Tests are not a panacea, though. We do not get feedback until we actually run the tests. Slow, nebulous tests give us slow, nebulous feedback, reducing their utility and lengthening the feedback cycle both through their slowness and through the infrequency we will consequently run them. We also rely on a developer <em>knowing</em> which tests to write. We can easily miss edge cases and other implicit assumptions in our tests. Tests also cannot enforce assumptions in the code itself. A developer can still unknowingly violate an assumption. </p> <h1>Conditionals</h1><p>  Conditionals embed our assumptions directly into the code we write. With conditionals, we are able to communicate bad assumptions back to the caller by returning error values or throwing exceptions. This way, we prevent bad assumptions from compounding through invalid state. We can also communicate the exact nature of the error, letting calling code handle it in appropriate way. Say, if the input came from a user entering values, we can show an error message with details. </p> <pre><code><br />/**<br /> * Divide the dividend by the divisor.<br /> * @param dividend the number to divide into<br /> * @param divisor the number to divide by<br /> * @return the dividend divided by the divisor, or NaN if the divisor is zero<br /> */<br />public static double divide(final double dividend, final double divisor) {<br />    if (divisor == 0.0) {<br />    	return Double.NaN;<br />    }<br /><br />    return dividend / divisor;<br />}<br /></code></pre> <p>  Here, we've changed the behavior of our <code>divide</code> method to return <code>Double.NaN</code> if the divisor is zero. Instead of allowing an unexpected fault to happen, we handle the case with code logic. The calling code can now rely on an assumption that this method will handle zero without blowing up, and will return a known value. The downside to conditionals is that they add logic to our running code. We have to maintain this code and understand the impact it has on the external behavior. Slow conditions that might only come up during development get checked on every execution in production. Conditionals also require some behavior for an unmet assumption, whether it be a thrown exception or a reasonable default value. There are cases where there is no such default value, and an exception would not be appropriate. </p> <h1>Assertions</h1><p>  At first glance, assertions look a lot like conditionals. The check a boolean condition, indicating an invalid state if that boolean condition is false. Assertions are not the same. They have several differences and advantages compared to plain conditionals. Assertions are not meant to change external behavior. While assertions indicate error, that error reporting is not considered part of the external interface of the code. This means we can make assertions about intermediate state inside a block of code without needing to change anything in the callers. For example, we may have a user interface for our <code>divide</code> method. That interface may use a number selector that automatically disallows a zero value for the divisor. That code could use an assertion to verify our <code>divide</code> method returns a value and not <code>Double.NaN</code>. </p> <pre><code><br />public void onEntryUpdated(final Form form) {<br />    final double dividend = form.getDoubleField("dividend");<br />    final double divisor = form.getDoubleField("divisor");<br /><br />    final double quotient = divide(dividend, divisor);<br />    assert quotient != Double.NaN;<br /><br />    form.setDoubleField("quotient", quotient);<br />}<br /></code></pre> <p>  In many languages, assertions have the added benefit of only being included or run in non-production environments. We get the security of assertions during production and testing, while avoiding the performance impact in production. The downside is that assertions not run in production don't guard against invalid assumptions in production. Ideally, assertions assert on conditions that only need verified during development and test. Otherwise, a full-blown conditional should be used instead. </p> <h1>Types and Encapsulation</h1><p>  The above methods (besides comments) attempt to enforce an assumption at the time the code is run by checking that a value meets expected criteria. However, we can leverage the type system and encapsulation to describe and enforce assumptions even earlier in the process. If we can't handle a zero value for a divisor, we can encapsulate this assumption into a type, and require that type be used. In the case of our <code>divide</code> method, we could create a <code>NonZeroDobule</code> type and use that type for the divisor parameter. </p> <pre><code><br />/**<br /> * Divide the dividend by the divisor.<br /> * @param dividend the number to divide into<br /> * @param divisor the number to divide by<br /> * @return the dividend divided by the divisor<br /> */<br />public static double divide(final double dividend, final NonZeroDouble divisor) {<br />    return dividend / divisor.doubleValue();<br />}<br /></code></pre> <p>  Since the <code>NonZeroDouble</code> type guarantees that we don't have a zero value, we don't need to check for zero. Calling code must pass in a non-zero value, or else they will get a compilation error. Constructing the <code>NonZeroDouble</code> instance will require its own assumption checks, most likely a conditional, but that check will be consolidated into a single place. This code will be unmistakably explicit about its assumption of a non-zero value, and an error becomes almost impossible. </p> <p>  In this specific case, we still need to account for a null value, meaning we don't gain a lot, but this kind of type explicitness is valuable in many places where we are dealing with potentially null values or more complex encapsulations. However, we need to make sure that these classes have enough meaning and value to carry their weight. In many cases, a <code>NonZeroDouble</code> value probably does not meet that standard. However, when small classes do offer enough value, they can be instrumental in making assumptions very explicit, providing immediate feedback and guaranteeing a higher level of correctness. </p> <p>  All of these different strategies have their place in making assumptions explicit. In many cases, we may end up using multiple strategies at the same time. We almost always want to have a comment where there is an assumption around the external interface of a piece of code. We may use a condition, then use an assertion to show that an impossible state really is impossible. By making our assumptions explicit in our code base, we know what the code expects and what the code produces, and we can proceed safe in our assumptions as we evolve the code. </p>]]></content>
	</entry>
	<entry>
		<id>https://medium.com/p/542d926935a3</id>
		<title>The Un-Sprint</title>
		<link rel="alternate" type="text/html" href="https://medium.com/ready-for-dev/the-un-sprint-542d926935a3?source=rss-3fc109936724------2"/>
		<published>2020-12-04T17:52:15Z</published>
		<updated>2020-12-04T17:52:15Z</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<div class="medium-feed-item"><p class="medium-feed-image"><a href="https://medium.com/ready-for-dev/the-un-sprint-542d926935a3?source=rss-3fc109936724------2"><img src="https://cdn-images-1.medium.com/max/2600/0*3vs93JbPlAF42fJM" width="3600"></a></p><p class="medium-feed-snippet">Avoid the sprint to nowhere</p><p class="medium-feed-link"><a href="https://medium.com/ready-for-dev/the-un-sprint-542d926935a3?source=rss-3fc109936724------2">Continue reading on Ready for Dev »</a></p></div>]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-44417601232433954</id>
		<title>Assuming Debugging</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2020/12/assuming-debugging.html"/>
		<published>2020-12-03T11:00:00-05:00</published>
		<updated>2020-12-03T11:00:05-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<p>  <a href="/TODO">Bugs are bad assumptions</a>. Debugging is the process of testing our assumptions until we discover the invalid one(s). Once found, we can then correct those bad assumptions. The following code generates blog post author statistics for a popular blog site. The statistics show which days of the week authors are making posts. Most of the authors post every day, and extra on Fridays and Saturdays to capture the weekend audience. It has at least one bug. </p> <pre><code><br />@GET<br />@Path("/authors/{email}/weekly-stats")<br />public UserWeeklyStats calculateWeeklyStats(@PathParam("email") final String email) {<br />    final User user = this.userService.byEmail(email);<br />    final Map&lt;LocalDate, List&lt;Post&gt;&gt; postsByDate =<br />            this.postService.thisWeekGroupedByDateFor(user.id());<br /><br />    if (postsByDate.isEmpty()) {<br />        return null;<br />    }<br /><br />    final Map&lt;DayOfWeek, List&lt;Post&gt;&gt; postsByDayOfWeek = new HashMap&lt;&gt;();<br />    postsByDate.forEach((date, post) -><br />        postsByDayOfWeek<br />                .computeIfAbsent(date.getDayOfWeek(), (key) -> new ArrayList&lt;&gt;())<br />                .add(post));<br /><br />    final Map&lt;DayOfWeek, Integer&gt; postCountByDayOfWeek = new HashMap&lt;&gt;();<br />    DayOfWeek favoriteDayOfWeek = DayOfWeek.SUNDAY;<br />    int maxPosts = 0;<br />    for (final DayOfWeek dayOfWeek : DayOfWeek.values()) {<br />        final int postCountForDayOfWeek = postsByDayOfWeek.get(dayOfWeek).size();<br /><br />        if (postCountForDayOfWeek > maxPosts) {<br />            favoriteDayOfWeek = dayOfWeek;<br />            maxPosts = postCountForDayOfWeek;<br />        }<br /><br />        postCountByDayOfWeek.put(dayOfWeek, Integer.valueOf(maxPosts));<br /><br />        if (dayOfWeek == LocalDate.now().getDayOfWeek()) {<br />            break;<br />        }<br />    }<br /><br />    return UserWeeklyStats.build()<br />        .withPostCountsByDayOfWeek(postCountByDayOfWeek)<br />        .withFavoriteWeekDay(favoriteDayOfWeek, maxPosts)<br />        .done();<br />}<br /></code></pre> <p>  We've received several tickets relating to this block of code. Some users report incorrect statistics, while others encounter 500 errors trying to see the numbers. Below are some of the bugs we've seen submitted. </p> <ul>  <li>Author statistics incorrect for Saturday</li>  <li>Author page does not load stats on Sunday mornings</li>  <li>Some West-Coast author pages do not load in the mornings</li>  <li>Bookmarked author page shows error</li></ul> <p>The first inclination might be to start reading through the code to see if we can spot the error. Or we might try to reproduce all the issues, probably with some but not all success. Instead, let's look at the assumptions we are making about this method, and see if we can glean knowledge that way. </p> <p>  We discover our assumptions by looking over the code and identifying them. We can write them down if necessary, or hold them in our head if they are few enough. Strong assumptions, like our compiler working, we can ignore for a first pass. It is far more likely that the bugs are in our code, and it is much better if they are because we can fix them. </p> <p>  Looking at the first few lines, we see that this is an HTTP GET endpoint. That enpoint has a user's email as a path parameter. That email address is extracted by our framework and passed in as a parameter to the method. Like the compiler, we can assume that the framework we are using is not the source of the bugs. Though it may have bugs, it is unlikely as this framework is widely used and bugs like this have mostly been ironed out. We see that our code passes this parameter to a service that will find the user. Here, the code assumes that the email string must actually be an email address, and that the email address corresponds to an author. It does no checking to ensure that an email is provided at all, and that it is actually an email address. This doesn't appear to correspond to any of our above bugs, but we should note it as a potential bug. If a user calls <code>/authors//weekly-stats</code> or <code>/authors/asdf/weekly-stats</code>, we probably want to fail fast and return a relevant error message to them. </p> <p>  We also see that our code assumes that we get back a valid user for the given email address. We do not check if the returned user is valid, or if the service method throws an error. We look through our list of bugs to see if any of them apply. The only one that seems tangentially related is the one about bookmarked author pages. Authors are free to change their email addresses in the system, and the bug report notes that it seems to only happen to authors that have changed their emails. Perhaps their bookmarks use their old email addresses. There is probably a larger fix to track old email addresses in the system, but at least we can return a clearer message to the user. </p> <p>  As we keep reading, we see that we get the author's posts for this week. If there are no author posts, we return a null and skip any further processing. In some code bases, this is fine, but we try to never return null values to the front-end in this code base. Because of that contract, the UI code is often written to assume some sort of value is always returned. In this case, we have an assumption we actually want to enforce, and we are breaking that assumption. There are a few tactics to fix this. We could return an error result saying there are no posts. We could wrap the result in an optional-type wrapper that will indicate if there is a value. We could return a default empty result that the UI could blissfully process unawares. These are all valid options, and which one is right depends on the exact situation. Looking through our ticket list, we see that failing to load on Sunday mornings would very likely be caused by this bad assumption. </p> <p>  Next we see that the code reads through this week's posts from the author, and groups them by the day of the week they were posted. This code safely handles each new day of the week it encounters by creating a new list for posts if it isn't already in the map. We then see values being set up for use in a loop. We notice that the code assumes that the day of the week for the most posts is Sunday by default. This default value assumption is likely wrong if the user has no posts. This is probably not a critical assumption, and we may note it and ignore it for now. </p> <p>  We come to a loop over the days of the week. It gets the number of posts for each day of the week and stores it in a map. It also calculates the author's most popular day of the week to post. This code makes several assumptions about the frequency of author posts. We loop over <em>every</em> day of the week and get the size of the list. The assumption here is that the author had a post every day of the week. If the author did not post one day, getting the list from the map will return null, and the code will throw an error. Most authors post at least once every day on the site, but they post throughout the day. If a user tries to see the authors statistics before an author has posted on a given day, they could encounter this error. It would affect authors on the West Coast more often, as they post later in the day due to time zone differences. The original developer was clever enough to notice this for later days in the week with the final conditional in the loop, but did not apply that same thought to passed days. We can strongly link this bad assumption to that bug. </p> <p>  Looking further at the code, we see the assumptions about picking the author's favorite day to post. That code assumes that the sizes will always make sense (will not be negative), will be reasonably comparable, and can be tracked to find the maximum to find the author's favorite. These are all safe assumptions, and this code is correct. </p> <p>  Finally we come to the line to set the number of posts for each day of the week. There is a pretty obvious bug in this line. We are passing in the maximum number of posts so far instead of the number of posts for this day. The line should be <code>postCountByDayOfWeek.put(dayOfWeek, Integer.valueOf(postCountForDayOfWeek));</code>. If the number of posts ascends for every day of the week, this code would work like it should. If the number of posts does not increase every day, then days after the previous maximum will be wrong. Authors post most articles on Fridays and Saturdays, but sometimes they post more on Friday than Saturday. Because of this, the number for Saturday will be wrong, instead showing Friday's number again. We see that we have a ticket for this. </p> <p>  Some might contend that this bug is not a bad assumption, but more likely a simple typo. It probably is a simple oversight by the developer intially, but there are many assumptions from there that are invalid. We assume that developers diligently test their code changes, manually or automatically. This developer did not check for a series of posts that is not strictly increasing, or else they would have caught this. Additionally, we assume that reviewers will also diligently read and test the code. That also did not happen in this case. Developers are people, and they sometimes make mistakes. They make mistakes and cannot catch every bug. To assume they can is wrong. Instead, we can make efforts to embed our assumptions into the code itself. </p> <p>  This is the second in a <a href="https://blog.cbojar.net/search/label/Assumed%20Bugs%20Series">series of posts on assumptions, bugs, debuggability, and maintainabilty</a>. </p>]]></content>
	</entry>
	<entry>
		<id>https://medium.com/p/eaa49f45be48</id>
		<title>Is Your Organization Suffering a Stroke?</title>
		<link rel="alternate" type="text/html" href="https://medium.com/ready-for-dev/is-your-organization-suffering-a-stroke-eaa49f45be48?source=rss-3fc109936724------2"/>
		<published>2020-11-20T19:05:41Z</published>
		<updated>2020-11-20T19:05:41Z</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<div class="medium-feed-item"><p class="medium-feed-image"><a href="https://medium.com/ready-for-dev/is-your-organization-suffering-a-stroke-eaa49f45be48?source=rss-3fc109936724------2"><img src="https://cdn-images-1.medium.com/max/904/1*ItURfOoRZIH7nxGpaq02HQ.png" width="904"></a></p><p class="medium-feed-snippet">What it is and how to spot the signs</p><p class="medium-feed-link"><a href="https://medium.com/ready-for-dev/is-your-organization-suffering-a-stroke-eaa49f45be48?source=rss-3fc109936724------2">Continue reading on Ready for Dev »</a></p></div>]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-5025805408910137414</id>
		<title>Assuming the Bugs</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2020/11/assuming-bugs.html"/>
		<published>2020-11-19T11:00:00-05:00</published>
		<updated>2020-11-19T11:00:04-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<p>  Writing code is all about making assumptions. Sometimes those assumptions are explicit, but more often we make those assumptions implicitly. We make assumptions about what kinds of parameters we will receive. We make assumptions about what kinds of values methods and functions will return. We make assumptions about the global state. The correctness of our code relies on the correctness of these assumptions. </p> <p>  Bad assumptions can wreck our applicatons. We assumed that method never returns null, but turns out it does. Now we have an unexpected <code>NullPointerException</code> crashing through our stack. We assume that we will always average at least one element. Turns out someone wants to average zero elements. Boom, division by zero, <code>ArithmeticException</code>. We make so many assumptions through our codebases, at least a few are going to be wrong. Really, there are many, many assumptions that are wrong. These are bugs. These bad assumptions are all of our bugs. </p> <p>  Usually, our assumptions are implicit, hidden to us and our fellow developers. These hidden assumptions make for hard-to-find bugs. We can attempt to find all the bugs reading through some code. For example, the following code reads a file and averages the numbers in that file. It seems like a reasonable piece of code. It is simple and direct, even using fancy Java 8 features. </p> <pre><code><br />public static double averageFile(final String fileName) throws IOException {<br />	final Path filePath = Paths.get(fileName);<br /><br />	final Stream&lt;String&gt; numberStrings = Files.lines(filePath);<br /><br />	final int[] numbers = numberStrings<br />        .mapToInt(Integer::parseInt)<br />        .toArray(int[]::new);<br /><br />	final int sum = IntStream.of(numbers).sum();<br /><br />	return ((double)sum) / numbers.length;<br />}<br /></code></pre> This code is pretty reasonable, but there are a lot of assumptions baked in. Below is the same code, annotated with many of the assumptions made on each line.  <pre><code><br />public static double averageFile(final String fileName) throws IOException {<br />    // We assume:<br />    // * fileName is a String<br />    // * fileName is not null<br />    // * fileName is not empty<br />    // * fileName is using a conformant path format (\ vs /, no illegal characters)<br />    final Path filePath = Paths.get(fileName);<br /><br />    // We assume:<br />    // * filePath is a Path<br />    // * filePath is not null<br />    // * filePath points to a file that exists<br />    // * filePath points to a file that is not a directory<br />    // * filePath points to a file that is readable<br />    // * filePath points to a file organized into separate lines<br />    // * filePath points to a file encoded in UTF-8<br />    final Stream&lt;String&gt; numberStrings = Files.lines(filePath);<br /><br />    // We assume:<br />    // * numberStrings is a Stream of Strings<br />    // * numberStrings is not null<br />    final int[] numbers = numberStrings<br />        // We assume:<br />        // * mapToInt will process every element in numberStrings<br />        // * mapToInt will return an IntStream of the parsed ints<br />        // * elements in numberStrings are not null<br />        // * elements in numberStrings are not empty<br />        // * elements in numberStrings are Strings<br />        // * elements in numberStrings contain one number per element<br />        // * elements in numberStrings do not contain whitespace<br />        // * elements in numberStrings do not contain non-number characters<br />        // * elements in numberStrings are not double values<br />        // * elements in numberStrings are not too big or small to be ints<br />        .mapToInt(Integer::parseInt)<br />        // We assume:<br />        // * this object is an IntStream<br />        // * this object is not null<br />        // * all of the elements in this IntStream are ints<br />        // * toArray will return an int array<br />        // * toArray will return an array of all of the ints in the IntStream<br />        // * there are few enough ints to fit into memory<br />        // * there are few enough ints to fit into an allocated array<br />        .toArray(int[]::new);<br /><br />    // We assume:<br />    // * numbers is an array of ints<br />    // * numbers is not null<br />    // * IntStream.of(int[]) produces a non-null IntStream of the given int array<br />    // * the sum method correctly sums all of the ints in the IntStream<br />    // * the sum of the ints does not overflow the maximum int<br />    final int sum = IntStream.of(numbers).sum();<br /><br />    // We assume:<br />    // * converting sum to a double will not lose necessary precision<br />    // * converting sum to a double will not alter the value in an invalid way<br />    // * numbers is not null<br />    // * numbers.length is not zero<br />    return ((double)sum) / numbers.length;<br />}<br /></code></pre> <p>  There are quite a few assumptions in there, and that's likely not every single one. Some assumptions are safer than others. Assumptions like "fileName is a String," and "filePath is a Path," are guaranteed by the language specification, and can be enforced by the compiler. When these kinds of assumptions are wrong, there is a bug, but it's in someone else's code. Other assumptions are still pretty safe without being enforced by the compiler. We know <code>Paths.get(fileName)</code> will not return a null value from its documentation. It will handle certain inputs, like an empty string, gracefully, and will throw an exception if it truly cannot handle a given input. </p><p>  There are also plenty of assumptions that would be bugs in our code. A blank line in the given file will break this code by failing to parse as an integer. Running this on an empty file will also fail because we will divide by zero in the last line. If we <strong>know</strong> these are safe assumptions, then maybe these will never be bugs. More often, users will test these assumptions thoroughly. </p> <p>  This is the first in a <a href="https://blog.cbojar.net/search/label/Assumed%20Bugs%20Series">series of posts on assumptions, bugs, debuggability, and maintainabilty</a>. </p>]]></content>
	</entry>
	<entry>
		<id>https://medium.com/p/afdd19ee5dd6</id>
		<title>Forget Estimating, Start Counting Instead</title>
		<link rel="alternate" type="text/html" href="https://medium.com/ready-for-dev/forget-estimating-start-counting-instead-afdd19ee5dd6?source=rss-3fc109936724------2"/>
		<published>2020-11-06T18:23:46Z</published>
		<updated>2020-11-06T18:23:46Z</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<div class="medium-feed-item"><p class="medium-feed-image"><a href="https://medium.com/ready-for-dev/forget-estimating-start-counting-instead-afdd19ee5dd6?source=rss-3fc109936724------2"><img src="https://cdn-images-1.medium.com/max/1127/1*sNssXrd6EmnwSiCGgApuyg.png" width="1127"></a></p><p class="medium-feed-snippet">Story points are a waste of time</p><p class="medium-feed-link"><a href="https://medium.com/ready-for-dev/forget-estimating-start-counting-instead-afdd19ee5dd6?source=rss-3fc109936724------2">Continue reading on Ready for Dev »</a></p></div>]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-3655221519119385896</id>
		<title>Name Your Problems</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2020/05/name-your-problems.html"/>
		<published>2020-11-05T11:00:00-05:00</published>
		<updated>2020-11-05T11:00:00-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<p>Sometimes when developing code, I run into problems. Ok, a lot of the times I run into problems, but there's a certain kind of problem I run into pretty often. The problem is that I want a thing that doesn't exist. I am writing code, and it is just getting gnarlier and more tangled around a pile of logic. At some point, I hit a wall with it. It is too complicated to really reason about, and I don't want to make things any worse. I've found a trick to solving these problems, though. I take those problems and give them a name. Once I do that, I can get a handle on them, manipulate them, or even sequester them off into a corner. In almost every case, this drastically reduces the complexity back down to a reasonable level, and I often get the side benefit of offering extensibility I didn't know I needed. </p><p>To demonstrate, let's say we are working on an e-commerce site. The company is based in Alabama, and sells to customers in all 50 states in the US. We have a method that computes the total price of the invoice that the customer gets charged. </p><pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br />    return total;<br />}<br /></code></pre><p>It is a simple bit of code that gets the job done. The problem is that many of the items we sell are subject to sales tax in their destinations, and we aren't calculating that in. This should be pretty straightforward, though. Let's start with adding sales tax for our home state, Alabama. Alabama charges a flat 4% sales tax on all items we sell. </p><pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    if (invoice.shippingAddress().state().equals("AL")) {<br />        total *= 1.04;<br />    }<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br />    return total;<br />}<br /></code></pre><p>That was easy. It made the code a little uglier, but not too bad. There are five states, Alaska, Delaware, Montana, New Hampshire, and Oregon, that don't charge sales tax. For them, we don't have to make any changes, meaning we are done! That's six states down, fourty-four to go. Let's do North Carolina next. They charge a flat 4.25% on all items we sell. </p><pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    if (invoice.shippingAddress().state().equals("AL")) {<br />        total += (total + 0.04);<br />    } else if (invoice.shippingAddress().state().equals("NC")) {<br />        total += (total * 0.0425);<br />    }<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br />    return total;<br />}<br /></code></pre><p>Ok, I think something is happening here. Each state we add is probably going to be a new condition on on this <code>if-else</code> chain. Since we are switching on the state value, let's switch this up to a case statement to make it a little cleaner. </p><pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    switch (invoice.shippingAddress().state()) {<br />    case "AL":<br />        total += (total * 0.04);<br />        break;<br />    case "NC":<br />        total += (total * 0.0425);<br />        break;<br />    default:<br />        // No sales tax<br />        break;<br />    }<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br />    return total;<br />}<br /></code></pre><p>Now it is a little clearer how to add a new state, and gives us a place to see that certain states don't collect income tax. Let's add a state where we have a lot of customers: Pennsylvania. Pennsylvania charges a 6% sales tax, but groceries and clothing are exempt. Some of the items we sell qualify as groceries and clothing, so we don't want to charge sales tax on those items. </p> <pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    switch (invoice.shippingAddress().state()) {<br />    case "AL":<br />        total += (total * 0.04);<br />        break;<br />    case "NC":<br />        total += (total * 0.0425);<br />        break;<br />    case "PA":<br />        double taxable = 0.0;<br />        for (Item item : invoice.items()) {<br />            if (item.category() != Category.GROCERY &amp;&amp;<br />                    item.category() != Category.CLOTHING) {<br />                taxable += item.price();<br />            }<br />        }<br /><br />        total += (taxable * 0.06);<br />        break;<br />    default:<br />        // No sales tax<br />        break;<br />    }<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br /><br />    return total;<br />}<br /></code></pre><p>That got ugly real quick. This does what we want, but this method is really starting to sprawl. If we keep going down the path we are going, this method is going to end up being bloated with all of this different tax logic. It will get hard to maintain. It is already getting hard to test. For each state, we need to add cases for each different condition within the tax calculation. To test the final value, we also need to calculate in the shipping cost by hand to get our expected values. Let's give all this tax calculation a name by pulling it out to a private method. </p><pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    total += calculateTax(invoice, total);<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br />    return total;<br />}<br /><br />private static double calculateTax(final Invoice invoice, final double total) {<br />    switch (invoice.shippingAddress().state()) {<br />    case "AL":<br />        return total * 0.04;<br />    case "NC":<br />        return total * 0.0425;<br />    case "PA":<br />        double taxable = 0.0;<br />        for (Item item : invoice.items()) {<br />            if (item.category() != Category.GROCERY &amp;&amp;<br />                    item.category() != Category.CLOTHING) {<br />                taxable += item.price();<br />            }<br />        }<br /><br />        return (taxable * 0.06);<br />    default:<br />        // No sales tax<br />        return 0.0;<br />    }<br />}<br /></code></pre><p>Things are a little better now. The tax calculation is no longer in the <code>calculateTotal</code> method. It is sequestered off into its own area. This still isn't great though. We haven't solved the testing problem, because we can only test this through the same public <code>calculateTotal</code> method. This is a necessary intermediate step, though. Only once it is in its own method can we cleanly move it to a new class, </p><pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    total += TaxCalculator.calculateTax(invoice, total);<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br />    return total;<br />}<br /><br />class TaxCalculator {<br />    public static double calculateTax(final Invoice invoice, final double total) {<br />        switch (invoice.shippingAddress().state()) {<br />        case "AL":<br />            return total * 0.04;<br />        case "NC":<br />            return total * 0.0425;<br />        case "PA":<br />            double taxable = 0.0;<br />            for (Item item : invoice.items()) {<br />                if (item.category() != Category.GROCERY &amp;&amp;<br />                        item.category() != Category.CLOTHING) {<br />                    taxable += item.price();<br />                }<br />            }<br /><br />            return (taxable * 0.06);<br />        default:<br />            // No sales tax<br />            return 0.0;<br />        }<br />    }<br />}<br /></code></pre><p>  This is much better. We've named the thing that was our problem. It is a tax calculator. This class is now isolated. It is easier to test because we can feed it inputs and get outputs directly. And we can change it in whatever way we feel like. Let's split out each state into its own private method to make them even more self-contained. </p><pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    total += TaxCalculator.calculateTax(invoice, total);<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br />    return total;<br />}<br /><br />class TaxCalculator {<br />    public static double calculateTax(final Invoice invoice, final double total) {<br />        switch (invoice.shippingAddress().state()) {<br />        case "AL":<br />            return calculateALTax(invoice, total);<br />        case "NC":<br />            return calculateNCTax(invoice, total);<br />        case "PA":<br />            return calculatePATax(invoice, total);<br />        default:<br />            // No sales tax<br />            return 0.0;<br />        }<br />    }<br /><br />    private static double calculateALTax(final Invoice invoice, final double total) {<br />        return total * 0.04;<br />    }<br /><br />    private static double caclulateNCTax(final Invoice invoice, final double total) {<br />        return total * 0.0425;<br />    }<br /><br />    private static double calculatePATax(final Invoice invoice, final double total) {<br />        double taxable = 0.0;<br />        for (Item item : invoice.items()) {<br />            if (item.category() != Category.GROCERY &amp;&amp;<br />                    item.category() != Category.CLOTHING) {<br />                taxable += item.price();<br />            }<br />        }<br /><br />        return (taxable * 0.06);<br />    }<br />}<br /></code></pre><p>  Interesting. Now that we've given names to all the individual pieces, we can see a pattern. Each state, internally, can calculate sales tax in their own way, but the interface is consistent between each state. Maybe a tax calculator is not a utility. Maybe it is a polymorphic type. Let's convert it to an interface. </p><pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    total += TaxCalculator.calculateTax(invoice, total);<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br />    return total;<br />}<br /><br />interface TaxCalculator {<br />    public static double calculateTax(final Invoice invoice, final double total) {<br />        switch (invoice.shippingAddress().state()) {<br />        case "AL":<br />            return new ALTaxCalculator().calculateTax(invoice, total);<br />        case "NC":<br />            return new NCTaxCalculator().calculateTax(invoice, total);<br />        case "PA":<br />            return new PATaxCalculator().calculateTax(invoice, total);<br />        default:<br />            // No sales tax<br />            return 0.0;<br />        }<br />    }<br /><br />    double calculate(Invoice invoice, double total);<br />}<br /><br />class ALTaxCalculator implements TaxCalculator {<br />    @Override<br />    public double calculate(final Invoice invoice, final double total) {<br />        return total * 0.04;<br />    }<br />}<br /><br />class NCTaxCalculator implements TaxCalculator {<br />    @Override<br />    public double caclulate(final Invoice invoice, final double total) {<br />        return total * 0.0425;<br />    }<br />}<br /><br />class PATaxCalculator implements TaxCalculator {<br />    @Override<br />    public double calculate(final Invoice invoice, final double total) {<br />        double taxable = 0.0;<br />        for (Item item : invoice.items()) {<br />            if (item.category() != Category.GROCERY &amp;&amp;<br />                    item.category() != Category.CLOTHING) {<br />                taxable += item.price();<br />            }<br />        }<br /><br />        return (taxable * 0.06);<br />    }<br />}<br /></code></pre><p>  Each state is now its own class. They can be tested and modified individually. We've gotten to a great place. The one thing that is still a little ugly is the static call to the <code>calculateTax</code> method. Each case in there is doing the same thing: creating an instance of the tax calculator for the state, then calling <code>calculate</code> on it. We can call the <code>calculate</code> method in the <code>calculateTotal</code> method if we have something that gives us back the right tax calculator. Let's move that <code>calculateTax</code> method over to a new class. </p><pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    total += TaxCalculators.calculateTax(invoice, total);<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br />    return total;<br />}<br /><br />class TaxCalculators {<br />    public static double calculateTax(final Invoice invoice, final double total) {<br />        switch (invoice.shippingAddress().state()) {<br />        case "AL":<br />            return new ALTaxCalculator().calculateTax(invoice, total);<br />        case "NC":<br />            return new NCTaxCalculator().calculateTax(invoice, total);<br />        case "PA":<br />            return new PATaxCalculator().calculateTax(invoice, total);<br />        default:<br />            // No sales tax<br />            return 0.0;<br />        }<br />    }<br />}<br /><br />interface TaxCalculator {<br />    double calculate(Invoice invoice, double total);<br />}<br /><br />class ALTaxCalculator implements TaxCalculator {<br />    @Override<br />    public double calculate(final Invoice invoice, final double total) {<br />        return total * 0.04;<br />    }<br />}<br /><br />class NCTaxCalculator implements TaxCalculator {<br />    @Override<br />    public double caclulate(final Invoice invoice, final double total) {<br />        return total * 0.0425;<br />    }<br />}<br /><br />class PATaxCalculator implements TaxCalculator {<br />    @Override<br />    public double calculate(final Invoice invoice, final double total) {<br />        double taxable = 0.0;<br />        for (Item item : invoice.items()) {<br />            if (item.category() != Category.GROCERY &amp;&amp;<br />                    item.category() != Category.CLOTHING) {<br />                taxable += item.price();<br />            }<br />        }<br /><br />        return (taxable * 0.06);<br />    }<br />}<br /></code></pre><p>  Now we can push that <code>calculateTax</code> call out of that method. We'll rename the method to signify the change in behavior. There is one wrinkle in this plan, though. For no sales tax, we don't do anything. We'll need a tax calculator to represent that. </p><pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    total += TaxCalculators.calculatorFor(invoice).calculateTax(invoice, total);<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br />    return total;<br />}<br /><br />class TaxCalculators {<br />    public static TaxCalculator calculatorFor(final Invoice invoice) {<br />        switch (invoice.shippingAddress().state()) {<br />        case "AL":<br />            return new ALTaxCalculator();<br />        case "NC":<br />            return new NCTaxCalculator();<br />        case "PA":<br />            return new PATaxCalculator();<br />        default:<br />            return new NoTaxCalculator();<br />        }<br />    }<br />}<br /><br />interface TaxCalculator {<br />    double calculate(Invoice invoice, double total);<br />}<br /><br />class NoTaxCalculator implements TaxCalculator {<br />    @Override<br />    public double calculate(final Invoice invoice, final double total) {<br />        return 0.0;<br />    }<br />}<br /><br />class ALTaxCalculator implements TaxCalculator {<br />    @Override<br />    public double calculate(final Invoice invoice, final double total) {<br />        return total * 0.04;<br />    }<br />}<br /><br />class NCTaxCalculator implements TaxCalculator {<br />    @Override<br />    public double caclulate(final Invoice invoice, final double total) {<br />        return total * 0.0425;<br />    }<br />}<br /><br />class PATaxCalculator implements TaxCalculator {<br />    @Override<br />    public double calculate(final Invoice invoice, final double total) {<br />        double taxable = 0.0;<br />        for (Item item : invoice.items()) {<br />            if (item.category() != Category.GROCERY &amp;&amp;<br />                    item.category() != Category.CLOTHING) {<br />                taxable += item.price();<br />            }<br />        }<br /><br />        return (taxable * 0.06);<br />    }<br />}<br /></code></pre><p>  The <code>TaxCalculators</code> class is looking a lot like a factory service. We can make it injectable. That would isolate the <code>calculateTotal</code> completely from the implementation of the tax calculators. </p><pre><code><br />public double calculateTotal(final Invoice invoice) {<br />    double total = invoice.subtotal();<br /><br />    total += this.taxCalculators.calculatorFor(invoice).calculateTax(invoice, total);<br /><br />    total += this.shippingService.calculateCost(invoice.shippingAddress());<br /><br />    return total;<br />}<br /><br />class TaxCalculators {<br />    public static TaxCalculator calculatorFor(final Invoice invoice) {<br />        switch (invoice.shippingAddress().state()) {<br />        case "AL":<br />            return new ALTaxCalculator();<br />        case "NC":<br />            return new NCTaxCalculator();<br />        case "PA":<br />            return new PATaxCalculator();<br />        default:<br />            return new NoTaxCalculator();<br />        }<br />    }<br />}<br /><br />interface TaxCalculator {<br />    double calculate(Invoice invoice, double total);<br />}<br /><br />class NoTaxCalculator implements TaxCalculator {<br />    @Override<br />    public double calculate(Invoice invoice, double total) {<br />        return 0.0;<br />    }<br />}<br /><br />class ALTaxCalculator implements TaxCalculator {<br />    @Override<br />    public double calculate(final Invoice invoice, final double total) {<br />        return total * 0.04;<br />    }<br />}<br /><br />class NCTaxCalculator implements TaxCalculator {<br />    @Override<br />    public double caclulate(final Invoice invoice, final double total) {<br />        return total * 0.0425;<br />    }<br />}<br /><br />class PATaxCalculator implements TaxCalculator {<br />    @Override<br />    public double calculate(final Invoice invoice, final double total) {<br />        double taxable = 0.0;<br />        for (Item item : invoice.items()) {<br />            if (item.category() != Category.GROCERY &amp;&amp;<br />                    item.category() != Category.CLOTHING) {<br />                taxable += item.price();<br />            }<br />        }<br /><br />        return (taxable * 0.06);<br />    }<br />}<br /></code></pre><p>  We've now reached a really good place. We can add tax calculators by adding a new class and updating the factory service. We can be sure everything works through testing. We were able to get here by giving a name to the problem we had. By creating the idea of a tax calculator, we were able to leverage that into better code. </p>]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-7999815973093959131</id>
		<title>Magic Numbers, Semantics, and Compiler Errors</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2020/02/magic-numbers-semantics-and-compiler.html"/>
		<published>2020-02-17T12:16:00-05:00</published>
		<updated>2020-02-17T12:16:50-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[Magic numbers are considered such a scourge upon code bases that there tools out there to automatically find them and root them out. After all, who knows what <code>setValue(6);</code> really means? There are also many approaches to giving better names to magic numbers. Not all of them are good, though. For example, we have a callback that sets a completion percentage on a status:<br /><br /><pre><code>void callback(Status status) {<br />    status.updateProgress(0, "Starting");<br />    // Do some stuff...<br />    status.updateProgress(25, "Some stuff done");<br />    // Do some more stuff<br />    status.updateProgress(50, "More stuff done");<br />    // Reticulating splines<br />    status.updateProgress(75, "Splines reticulated");<br />    // Validate everything<br />    status.updateProgress(100, "Complete");<br />}</code></pre><br />Those percentages would get flagged as magic numbers by the automatic tools. The developer would need to extract those out to constants to make that tool happy. A thoughtful developer would create well-named, class-level constants for each percentage:<br /><br /><pre><code>private static final int ZERO_PERCENT = 0;<br />private static final int TWENTY_FIVE_PERCENT = 25;<br />private static final int FIFTY_PERCENT = 50;<br />private static final int SEVENTY_FIVE_PERCENT = 75;<br />private static final int ONE_HUNDRED_PERCENT = 100;<br /><br />void callback(Status status) {<br />    status.updateProgress(ZERO_PERCENT, "Starting");<br />    // Do some stuff...<br />    status.updateProgress(TWENTY_FIVE_PERCENT, "Some stuff done");<br />    // Do some more stuff<br />    status.updateProgress(FIFTY_PERCENT, "More stuff done");<br />    // Reticulating splines<br />    status.updateProgress(SEVENTY_FIVE_PERCENT, "Splines reticulated");<br />    // Validate everything<br />    status.updateProgress(ONE_HUNDRED_PERCENT, "Complete");<br />}</code></pre><br />A more hapless developer, or even one mass-fixing magic constants, would not take as much care:<br /><br /><pre><code>private static final int ZERO = 0;<br />private static final int TWENTY_FIVE = 25;<br />private static final int FIFTY = 50;<br />private static final int SEVENTY_FIVE = 75;<br />private static final int ONE_HUNDRED = 100;<br /><br />void callback(Status status) {<br />    status.updateProgress(ZERO, "Starting");<br />    // Do some stuff...<br />    status.updateProgress(TWENTY_FIVE, "Some stuff done");<br />    // Do some more stuff<br />    status.updateProgress(FIFTY, "More stuff done");<br />    // Reticulating splines<br />    status.updateProgress(SEVENTY_FIVE, "Splines reticulated");<br />    // Validate everything<br />    status.updateProgress(ONE_HUNDRED, "Complete");<br />}</code></pre><br />We've lost the notion that these are percentages. But that same developer might be even more "helpful" and notice we use those same numbers in other places. They should all be in a shared constants file:<br /><br /><pre><code>public class AppConstants {<br />    public static final int ZERO = 0;<br />    public static final int TWENTY_FIVE = 25;<br />    public static final int FIFTY = 50;<br />    public static final int SEVENTY_FIVE = 75;<br />    public static final int ONE_HUNDRED = 100;<br />}<br /><br />void callback(Status status) {<br />    status.updateProgress(AppConstants.ZERO, "Starting");<br />    // Do some stuff...<br />    status.updateProgress(AppConstants.TWENTY_FIVE, "Some stuff done");<br />    // Do some more stuff<br />    status.updateProgress(AppConstants.FIFTY, "More stuff done");<br />    // Reticulating splines<br />    status.updateProgress(AppConstants.SEVENTY_FIVE, "Splines reticulated");<br />    // Validate everything<br />    status.updateProgress(AppConstants.ONE_HUNDRED, "Complete");<br />}</code></pre><br /><a target="_blank" href="https://thedailywtf.com/articles/A_Constant_Barrage">The automated tools are happy</a>, and we've even made our code more DRY! We could use any one of our application constants, like <code>AppConstants.TWO_HUNDRED</code>. Oh, wait, that isn't a valid percentage. Or we could use <code>AppConstants.LONG_BITS_COUNT</code>. That isn't even trying to be a percentage. That's not good. We've given the numbers names and moved them around, but we haven't improved the semantics of those values. They are just as meaningless as constants as they were as raw values. We may have dug ourselves into a hole. Let's back up and see if we can do something different.<br /><br />Percentages are a well-defined concept. They are values from 0 to 100, inclusive. They should never be negative, and they should never be greater than 100. Because our code is using <code>int</code> types, we know they shouldn't have fractional components either. These constraints are not all expressed by using an <code>int</code>. We could pass in invalid values outside of the range.<br /><br /><div style="text-align:center;"><img border="0" src="https://2.bp.blogspot.com/-eLc1mxNU4_k/XiXiISFpcqI/AAAAAAAABH4/cijnTWEF2fUOccIkqSb9nTwnXGyapw4UACLcBGAsYHQ/s1600/255-percent.png" data-original-width="212" data-original-height="67" /><br /></div><br />The <code>updateProgress</code> method on <code>Status</code> could have a runtime check on the values. This approach has two shortcomings though. First, we would not know if we gave an invalid value until we ran the code. Second, the <code>updateProgress</code> method now has to do more things. If we have percentages in other places, they also have to do the same checking, repeating code across the code base.<br /><br />Because percentage is a well-defined concept, we could instead encode it as a type in our system:<br /><br /><pre><code>public enum Percent {<br />    // We could define every percent from 0 to 100, but our app only uses these right now.<br />    ZERO(0),<br />    TWENTY_FIVE(25),<br />    FIFTY(50),<br />    SEVENTY_FIVE(75),<br />    ONE_HUNDRED(100);<br /><br />    private final int numericValue;<br /><br />    Percent(int numericValue) {<br />        assert numericValue >= 0 && numericValue <= 100;<br />        this.numericValue = numericValue;<br />    }<br /><br />    @Override<br />    public String toString() {<br />        return numericValue + "%";<br />    }<br />}</code></pre><br />We've defined percentage semantically. It is its own thing now. We don't need to use a primitive type masquerading as a percentage. We can trivially add more values. We've put in an assertion on the boundaries of the numeric value we can have. We now don't need to check our bounds everywhere else. The developer will get an error as soon as the enum is loaded if they create a value outside of the boundaries. There will never be an invalid <code>Percent</code> instance. Weaving our type into the code, we would now see:<br /><br /><pre><code>void callback(Status status) {<br />    status.updateProgress(Percent.ZERO, "Starting");<br />    // Do some stuff...<br />    status.updateProgress(Percent.TWENTY_FIVE, "Some stuff done");<br />    // Do some more stuff<br />    status.updateProgress(Percent.FIFTY, "More stuff done");<br />    // Reticulating splines<br />    status.updateProgress(Percent.SEVENTY_FIVE, "Splines reticulated");<br />    // Validate everything<br />    status.updateProgress(Percent.ONE_HUNDRED, "Complete");<br />}</code></pre><br />We've not only given a better name to our constants, but given ourselves a compile-time check that we aren't using an invalid percentage. We also can't inadvertently pass in a length or a number of seconds where we really need a percentage. Our code now has a greater semantic meaning than it would have with the primitive constants alone. Our code will fail to compile, giving us immediate feedback. This means that our code will be more correct and have fewer errors. It will be easier to maintain. It will be better code.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-6412364791738703161</id>
		<title>Typing != Complexity</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2018/12/typing-complexity.html"/>
		<published>2018-12-13T11:00:00-05:00</published>
		<updated>2018-12-13T11:00:08-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[Developers of all experience levels commonly share a false belief: more typing means more complexity. The most powerful idioms and tools often require a few extra keystrokes, but dramatically <em>reduce</em> complexity.<br /><br />The <a href="https://en.wikipedia.org/wiki/Final_(Java)" target="_blank"><code>final</code></a> keyword in Java is a bit of extra typing. The <code>final</code> keyword can be applied to variables, method parameters, instance members, static members, methods, and classes. By making these final, their values will not depend on their context. They will be known constants through their lifetime. Their constancy removes a large cognitive load. The developer no longer needs to worry if the value was not set or if it was set multiple times. Many developers forgo this benefits to avoid typing the extra keyword, to their own detriment. Later, they spend too much time chasing down defects caused by mutable state.<br /><br />Developers will often shun creating small types and interfaces because of the extra typing involved. Interfaces can abstract away many different implementations behind a simpler facade. Adding new implementations would only require creating a new class. Instead, many developers will create long-winded conditional chains of all the behaviors. These chains are repeated in many places, opening the possibility for defects through inconsistencies. Conditionals are harder to understand and change than focused classes. <a href="https://blog.cbojar.net/2017/06/making-wrong-code-be-wrong.html">Small types</a> allow us to use the compiler to find defects and document expectations in the code. A primitive integer can represent a distance, a duration, or any number of other numeric values. A wrong value in the wrong place can be <a target="_blank" href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure">disastrous</a>. A <code>Duration</code> instance cannot be wrongly used in place of a <code>Distance</code> though. This guarantee is enforced by the compiler, and will not be overlooked or side-stepped.<br /><br />Programming languages, like natural languages, are built for people. And like natural languages, they cannot always be maximally terse and maximally expressive. For people, expressiveness is the more valuable attribute. With programming languages, the expressiveness carries added benefits. We can create stronger assurances against defects, and fail earlier. All for the price of a little extra typing.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-8870995329203374114</id>
		<title>The Cohort of Responsibility</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2018/11/the-cohort-of-responsibility.html"/>
		<published>2018-11-29T11:00:00-05:00</published>
		<updated>2018-11-29T11:00:14-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[Sometimes the team just isn't enough.<br /><br />Delivering business value from idea to production is a complex endeavor. Development teams sit squarely in the middle of that process. Ideally, they are talking directly to <a target="_blank" href="http://blog.daverooney.ca/2007/04/customer-role-in-agile-development.html">the customer</a>. Often in real life, business analysts collect requirements from customers and pass them to the development team. On the other side, development interacts with operations to deploy and run the software.<br /><br />All of these groups, and more, have the responsibility to deliver the business value. But too often, there is friction between these groups on the path. Not everyone wants to move in the same direction. Some individuals or groups can slow down or altogether stop value from being delivered. They are <em>responsible</em>, but not always <em>accountable</em>.<br /><br />Everyone who bears direct responsibility toward delivering business value is part of the <strong>Cohort of Responsibility</strong> in the organization. To most easily identify everyone in the cohort, we can pick out everyone who must touch a requirement along its path from customer all the way back to customer as finished product. These are the people that must do something or it will never get delivered.<br /><br />The first and foremost member of the cohort is the customer themselves. Since the customer is not a member of the organization, they are "half-in" both at the start of the process, for creating ideas, and at the end of the process, for receiving the value. All cohorts of responsibility start and end with the customer. If the customer is not part of the cohort, there are no guarantees that the process is creating and delivering any value at all.<br /><br />Inside of the organization, the development, business analysis, quality assurance, security, and operations teams are all part of the cohort. Those functions are all needed for delivering quality product (though some organizations may divvy those capabilities across a different arrangement of actual teams). Those teams all bear responsibility and execute the different parts of the <a target="_blank" href="https://en.wikipedia.org/wiki/Value_stream_mapping">value stream</a>. For the best outcomes, they need to work together to deliver.<br /><br />Unfortunately, the business may not have the same expectations for all these teams. Operations is judged by uptime and stability. Quality assurance measures defects found. Development counts code delivered. Sometimes these metrics conflict with each other. Adding new code means decreased stability and uptime, for example. Friction arises from these conflicts.<br /><br />The cohort of responsibility needs to be assessed on a uniform standard stretching from end to end. The entire chain needs to deliver business value to the customer. The cohort needs to work together across team lines to accomplish this. They need to truly share the goal of delivering business value. They need to find a globally optimal solution that balances all the needs against the goal. They need a management and business structure that understands and supports them.<br /><br />The easiest way to do this would be to just have a single team encompassing the entire cohort. They will be <a target="_blank" href="https://leankit.com/learn/lean/what-are-cross-functional-teams/">cross-functional</a>. They will have a single leader, a single standard of measurement, and a single measure of accountability. This would eliminate all of the friction between different teams. The team would be fully self-sufficient.<br /><br />Not every organization can have a single team, though. The teams might be too large. Or there might be bureaucratic impediments to unifying all of the functions. Having distinct teams that work closely together with frequent communication can provide the same benefits. Frequent communication lubricates the contact between the teams, reducing the friction. It will not be as smooth as on a single team, but it can be smooth enough to work effectively.<br /><br />The biggest challenge the cohort faces is its own sheer size. The cohort should not include extraneous members because the process should not contain extraneous steps. The process and the cohort should be simplified as much as reasonable to get them working to their highest effectiveness.<br /><br />By identifying, understanding, and coordinating the cohort of responsibility, we can deliver better value faster.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-4742638341578841725</id>
		<title>Velocity is not a Business Metric</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2018/11/velocity-is-not-business-metric.html"/>
		<published>2018-11-01T06:00:00-04:00</published>
		<updated>2018-11-01T06:00:00-04:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[Nowadays, every <a target="_blank" href="https://www.youtube.com/watch?v=HZyRQ8Uhhmk">Agile&trade;</a> organization is intently focused on increasing <a target="_blank" href="https://en.wikipedia.org/wiki/Velocity_(software_development)">velocity</a>. It's obvious: higher velocity means more productivity and efficiency, right? Because of this, managers and team leaders and product owners the world over are tracking team velocity. With it, they demand estimates, make projections, and kick off marketing campaigns. They are often led astray by velocity.<br /><br />Because <em>velocity is not a business metric</em>.<br /><br />Velocity is an imprecise metric in the best cases. We calculate it from an estimation metric over a defined period of time. Story points are the most commonly used metric. Story points are a team's best guess at how large a story will be relative to other stories. A story is assigned a number of points at some point before development starts on it. The points are credited to the team's velocity when the story is considered done. Ideally, velocity is fairly stable over time. Using velocity (say, 12 points/week), we can extrapolate an entire project (about 132 points) to determine the project's duration (132 points / 12 points/week = 11 weeks).<br /><br />From that description alone, we see challenges using story points as a business metric. First, story points are relative and fuzzy. Developers are guessing how big a story might be before doing any work on it. It might be much smaller and simpler than expected. It might be much larger and more complicated. Even though these variations should smooth out in the long term, they introduce uncertainty in the short and medium terms. Teams do not stay stagnant. A maturing or changing team will change the baseline they use to guess story points. The value of a point will change over time. Projects also do not stay stagnant. A story point estimation of a story will not be consistent throughout the project.<br /><br />Second, story points are team-specific. Different teams will make different story-point estimations for what are otherwise similar stories. Since the metric itself is not comparable across teams, velocity also is not comparable. Directly ranking teams by their raw velocities misleads the business on the true output of each of the teams. Teams competing on velocity will simply increase the points-per-story. This will increase their velocity while not actually changing their productivity.<br /><br />Some business try to overcome these shortcomings by standardizing. One point is half a day, two points are a whole day, etc. Therefore, every member of every team completes about 10 points every week. We've solved the problem with variation. Or have we? Different teams produce at different rates for many reasons. Dictating the points does not change that fact. Teams will make up whatever numbers they need to so the business sees what they want to. Velocity looks approximately constant, but actual production varies wildly. The ability of the team to detect and diagnose their own problems from their velocity is lost. The business has actually made things <strong>worse</strong>.<br /><br />Velocity can be useful to a team to measure themselves over time. They can track changes in productivity, determine what is causing those changes, and make adjustments accordingly. The business outside of the team cannot see this with velocity. Their reactions would be ill-informed and therefore ill-advised. The business instead needs to focus on meaningful business metrics. The primary metric should be the delivery of business value. Business value is the only thing that matters to the business. The biggest shortcoming of story points, and therefore velocity, is that they measure estimated effort. But effort does not always correlate to value. A smaller task may have a high value while a larger one a small value. The interest of the business is encouraging the team to deliver that value. So they need to focus on that, not velocity.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-8454600711349180646</id>
		<title>Respect Your Callers&apos; Intentions</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2018/10/respect-your-callers-intentions.html"/>
		<published>2018-10-25T06:00:00-04:00</published>
		<updated>2018-10-25T06:00:01-04:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[When we write code, we write it to be used. We call it from other places in our application. Others call it from places in their application. When we are writing code, we should show what we mean through our code, an idea known as <a href="http://xunitpatterns.com/Intent%20Revealing%20Name.html" target="_blank">intention-revealing interfaces</a>. We reveal intentions through the external surface we expose. But what intentions are we exposing?<br /><br />We write our code in a way that we think will be useful, but we are mostly writing implementation. We are writing what the code should do, and then from there how others would use it. The implementation drives the interface. The implementation does not always have the right intentions, though. Here's a simple class that stores historic temperature data for processing:<br /><br /><pre><code><br />public class TemperatureHistory {<br />    private int[] temperatures;<br /><br />    public TemperatureHistory(int[] temperatures) {<br />        this.temperatures = temperatures;<br />    }<br /><br />    public int[] getTemperatures() {<br />        return temperatures;<br />    }<br />}<br /></code></pre><br />This is a simple data class. All it does is hold the temperature data, and there is no behavior on this class. In isolation, we don't entirely know if this class serves a valuable purpose or not, but we can look at the callers of this class to see how they are using it:<br /><br /><pre><code><br />public int calculateAverageTemperature(TemperatureHistory temperatures) {<br />    int total = 0;<br />    for (int temperature : temperatures.getTemperatures()) {<br />        total += temperature;<br />    }<br /><br />    return total / temperatures.getTemperatures().length;<br />}<br /><br />public int findHighInLast30Days(TemperatureHistory temperatures) {<br />    int startIndex = Math.max(0, temperatures.getTemperatures().length - 30);<br />    int high = Integer.MIN_VALUE;<br /><br />    for (int i = startIndex; i < temperatures.getTemperatures().length; i++) {<br />        if (temperatures.getTemperature()[i] > high) {<br />            high = temperatures.getTemperature()[i];<br />        }<br />    }<br /><br />    return high;<br />}<br /><br />public boolean shouldCoverPlants(TemperatureHistory temperatures) {<br />    int startIndex = Math.max(0, temperatures.getTemperatures().length - 7);<br /><br />    for (int i = startIndex; i < temperatures.getTemperatures().length; i++) {<br />        if (temperatures.getTemperature()[i] <= 32) {<br />            // If any day in the last week was below freezing, we should cover plants<br />            return true;<br />        }<br />    }<br /><br />    return false;<br />}<br /><br />// etc...<br /></code></pre><br />We see that the interface of the <code>TemperatureHistory</code> class is not sufficient. Callers have to do a lot of work to massage the data returned into a useful form. The interface of the <code>TemperatureHistory</code> class was driven by the internal implementation of an array of integers. The calling code could make use of a better structure for their purposes. Some of this behavior would also be better suited to live in the <code>TemperatureHistory</code> class, hiding the implementation details completely from the callers. An improved <code>TemperatureHistory</code> class might look like:<br /><br /><pre><code><br />public class TemperatureHistory {<br />    private int[] temperatures;<br /><br />    public TemperatureHistory(int[] temperatures) {<br />        this.temperatures = temperatures;<br />    }<br /><br />    public TemperatureHistory lastNDays(int days) {<br />        int startIndex = Math.max(0, temperatures.length - days);<br />        int actualDays = temperatures.length - startIndex;<br />        int[] window = new int[actualDays];<br /><br />        for (int i = startIndex; i < temperatures.length; i++) {<br />            window[i - startIndex] = temperatures[i];<br />        }<br /><br />        return new TemperatureHistory(window);<br />    }<br /><br />    public int high() {<br />        int high = Integer.MIN_VALUE;<br /><br />        for (int temperature : temperatures) {<br />            if (temperature > high) {<br />                high = temperature;<br />            }<br />        }<br /><br />        return high;<br />    }<br /><br />    public int low() {<br />        int low = Integer.MAX_VALUE;<br /><br />        for (int temperature : temperatures) {<br />            if (temperature < low) {<br />                low = temperature;<br />            }<br />        }<br /><br />        return low;<br />    }<br /><br />    public int average() {<br />        int total = 0;<br />        for (int temperature : temperatures) {<br />            total += temperature;<br />        }<br /><br />        return total / temperatures.length;<br />    }<br /><br />    public int[] getTemperatures() {<br />        return temperatures;<br />    }<br />}<br /></code></pre><br />We have evolved the <code>TemperatureHistory</code> class to better suit the callers' intentions. It isn't perfect. We still have the <code>getTemperatures</code> method that doesn't tell us much, but we don't want to change all the code everywhere right this instant. There are other bits of the implementation that can be refactored, but we have focused our efforts on the interface first. Our callers can now be improved as well:<br /><br /><pre><code><br />public int calculateAverageTemperature(TemperatureHistory temperatures) {<br />    return temperatures.average();<br />}<br /><br />public int findHighInLast30Days(TemperatureHistory temperatures) {<br />    return temperatures.lastNDays(30).high();<br />}<br /><br />public boolean shouldCoverPlants(TemperatureHistory temperatures) {<br />    return temperatures.lastNDays(7).low() <= 32;<br />}<br /><br />// etc...<br /></code></pre><br />All of these callers were dramatically improved. Five or six lines each is reduced to a single line. Not every call will become a single line, but we have moved much of the common complexity into the <code>TemperatureHistory</code> class, leaving the callers to clearly declare what they actually want in language that is straightforward and concise.<br /><br />It is the <strong>callers</strong> that determine what the interface of the code should be, not the implementation. We should always write code with the callers in mind. When we write from the callers' perspective, our code will be more useful and more valuable to them, benefiting everyone.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-5416922276669240554</id>
		<title>I&apos;m Almost Always Wrong (The First Time)</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2018/10/im-almost-always-wrong-first-time.html"/>
		<published>2018-10-18T06:00:00-04:00</published>
		<updated>2018-10-18T06:00:05-04:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[When I write a chunk of code, it is wrong. I know it is wrong, even as I am writing it. But there's nothing I can do about it. I don't, and <em>can't</em> know how it is wrong when I am writing it. I can only know that I am writing wrong code. I am not phased in the least.<br /><br />As professionals, we are expected to write code with a certain quality of <a href="http://wiki.c2.com/?MaintainAbility" target="_blank">maintainability</a> so that our code can be easily changed in the future. This is expected because of how often code <em>does</em> need to change, often in unexpected ways. We cannot predict all the ways the code needs to change. The future is inherently unpredictable. We must write our code in a way that makes changes as straightforward as possible.<br /><br />I don't worry about writing wrong code. I write it in a way that I can make right later. I design seams in places that seem most likely to change. I know them by the uncertainty that lives in them. I abstract and encapsulate that uncertainty behind methods and classes and interfaces so that later, when I need to change everything, I have a place to do it without needing to start from scratch.<br /><br />Because I almost always write the wrong code the first time, I rely on coming back around later and refactoring. Sometimes, this refactoring happens before anyone else even sees the code. I've tossed out and replaced whole implementations because they didn't fit with what the code needed to do. I didn't lose anything, though, because I learned from what I did, and I could preserve the parts that were more correct.<br /><br />My wrongness is not a personal failing, but a reality of being a human working in a complex and dynamic domain. I am not alone. Every developer shares these characteristics. If they did not, we would never have a need for version 2 of anything. We must not shy away from the wrongness because that is the path to (more) right answer.<br /><br />The biggest danger we face is when we are expected to be perfect the first time around. If we can never go back and fix the wrongness we discover, the wrongness will accrete until the system is more wrong than right. We will constantly be fighting to change a system like that, and it will never <em>really</em> be able to fully adapt to the changing demands on it. A persistent <a href="https://en.wikipedia.org/wiki/Technical_debt" target="_blank">technical debt</a> hangs over the project.<br /><br />It isn't always straightforward to justify fixing the wrongness if externally it seems to "work." If the code does at least what it promises to do, it isn't broken. We must resist this line of thinking. Just as bad things <em>eventually</em> happen if we never change the oil in our car, bad things can happen to the code if we don't take the time to fix them.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-1868735079740796316</id>
		<title>When Technical Debt Costs You MORE!</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2018/10/when-technical-debt-costs-you-more.html"/>
		<published>2018-10-11T06:00:00-04:00</published>
		<updated>2018-10-11T06:00:03-04:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[We've all heard of the metaphor of <a target="_blank" href="https://en.wikipedia.org/wiki/Technical_debt">technical debt</a> by now. Maintaining poorly written software costs more in the long term, even if it saves in the short term. Thinking of this as a form of debt helps explain this in terms business-oriented stakeholders can understand.<br /><br />Metaphors are valuable because they can meaningfully convey a concept through a different context. They bridge the gap between two different ways of thinking. Sometimes we can take the metaphors a little too far, and they become disconnected from what they are actually trying to represent. This has happened with the metaphor of technical debt. Other times, we can explore the metaphor to find deeper relationships between the real concepts and the metaphorical ones.<br /><br />Financial debt has the concept of interest in it. Interest is an extra charge on top of the original value lent. It covers risk and provides incentive to the lender. It is calculated as a percentage on top of the principle amount of the loan. So a loan of $1,000 with an annual interest rate of 5% incurs $50 of interest in a year.<br /><br />Technical debt is not as easy to quantify, but the idea of interest carries over. The interest on technical debt is manifest in the need for change. Code needs to change to meed new needs and new demands. Code that is technical debt is hard to change, and costs more when it does need to change. The additional cost comes in the form of time spend to understand what the code is doing, time spent refactoring the code, time spent shoe-horning in a change that could be simpler, and time spent fixing bugs because the code is too complicated. If the debt is not paid off through refactoring, the interest keeps accruing every time that code needs touched.<br /><br />This definition, equating the rate of interest to the rate of change, leads us to a few conclusions. First, we see that if we need to change a bad piece of code often, that code is more expensive. Conversely, bad code we never or rarely change doesn't cost as much. The "interest rate" is lower for code that doesn't change. From this, we can see that we need to focus refactoring efforts on high-traffic code. We should do the refactoring as we are making changes to that code as we are already taking on the risk of making changes. We should also use automated tests to "collateralize" our technical debt, lowering the risk of change when we do need to make those changes.<br /><br />By seeing the technical debt as not just a static metric, but as one that grows over time, we can make the case to address the right debt first for the best outcomes.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-2572694887514309858</id>
		<title>Untangling Nested Code</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2018/02/untangling-nested-code.html"/>
		<published>2018-02-19T12:31:00-05:00</published>
		<updated>2018-02-19T12:31:22-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<a href="https://pixabay.com/en/matryoshka-russian-dolls-nesting-970943/"><img title="Russian nesting dolls" src="https://4.bp.blogspot.com/-CW4t2SMPh1k/WkrmTyzM8AI/AAAAAAAABAI/PcoG3Pvku14P1RtGyF7X4rRXwRikVL0kgCLcBGAs/s1600/matryoshka-970943_640.jpg" /></a><br /><br />There is code out there that is ugly. I mean really ugly. I know, can you believe it? But it's true. One such example of really ugly code is code that has lots of deeply nested calls. The tests are trying to test a dozen different methods in every case. The methods look so simple with just a few lines and a few calls. And then those methods called have a few lines and a few calls. And then again, a dozen or more different calls deep.<br /><br />We want to use private helper methods to make our code clearer and cleaner. Calling methods is also largely what programming is about. But sometimes we overdo it. Deep call hierarchies are difficult to follow and they can mask what the code is really doing. Each call means that we have to look all over a class to see what actually happens. This makes debugging hard. This makes testing even harder.<br /><br />Say we have the following code:<br /><br /><pre><code><br />class DataLoader {<br />    void loadNationalData(Nation nation, int year, DataReader reader) {<br />        for (State state : nation.states()) {<br />            if (!state.isParticipating(year)) {<br />                continue;<br />            }<br /><br />            loadStateData(state, year, reader);<br />        }<br />    }<br /><br />    private void loadStateData(State state, int year, DataReader reader) {<br />        for (County county : state.counties()) {<br />            if (county.hasDataFor(year)) {<br />                loadCountyData(county, year, reader);<br />            }<br />        }<br />    }<br /><br />    private void loadCountyData(County county, int year, DataReader reader) {<br />        for (DataBlock dataBlock : county.dataBlocksFor(year)) {<br />            if (dataBlock.dataPoints().size() &gt;= 100) {<br />                for (DataPoint dataPoint : dataBlock.dataPoints()) {<br />                    reader.read(dataPoint);<br />                }<br />            }<br />        }<br />    }<br />}<br /></code></pre><br />We have three methods that are called nested from top to bottom. When we use <code>loadNationalData</code>, we must use <code>loadStateData</code>, and in turn we must use <code>loadCountyData</code>. This make sense when we want to call <code>loadNationalData</code> from code, but we don't necessarily want to do that from tests. We would like to test these methods separately to make sure each works individually without testing everything together. How can we un-nest these method calls?<br /><br />Let's first look at what the <code>loadCountyData</code> method is doing: looping over data blocks for a given year in a given county, filtering out data blocks that do not have a minimum number of data points, then feeding those data points into the data reader. This method is doing more than one thing. We can split up some of the things into separate blocks of code:<br /><br /><pre><code><br />    private void loadCountyData(County county, int year, DataReader reader) {<br />        Iterable&lt;DataBlock&gt; dataBlocks = county.dataBlocksFor(year);<br />        List&lt;DataPoint&gt; dataPoints = new ArrayList&lt;&gt;();<br /><br />        for (DataBlock dataBlock : dataBlocks) {<br />            if (dataBlock.dataPoints().size() &gt;= 100) {<br />                dataPoints.addAll(dataBlock.dataPoints());<br />            }<br />        }<br /><br />        for (DataPoint dataPoint : dataPoints) {<br />            reader.read(dataPoint);<br />        }<br />    }<br /></code></pre><br />Now we have a top chunk that is filtering out all the points from data blocks that do not meet the minimum. We've also extracted the code for getting data blocks from the county to a local variable as part of that top chunk. We have a bottom chunk that is dispatching those data points to the data reader. We can extract two methods along those lines. This temporarily makes the nesting worse in this class:<br /><br /><pre><code><br />    private void loadCountyData(County county, int year, DataReader reader) {<br />        Iterable&ltDataBlock&gt; dataBlocks = county.dataBlocksFor(year);<br />        Iterable&lt;DataPoint&gt; dataPoints = filterDataBlocks(dataBlocks);<br /><br />        writeDataPoints(dataPoints, reader);<br />    }<br /><br />    private Iterable&lt;DataPoint&gt; filterDataBlocks(Iterable&lt;DataBlock&gt; dataBlocks) {<br />        List&lt;DataPoint&gt; dataPoints = new ArrayList&lt;&gt;();<br /><br />        for (DataBlock dataBlock : dataBlocks) {<br />            if (dataBlock.dataPoints().size() &gt;= 100) {<br />                dataPoints.addAll(dataBlock.dataPoints());<br />            }<br />        }<br /><br />        return dataPoints;<br />    }<br /><br />    private void writeDataPoints(Iterable&lt;DataPoint&gt; dataPoints, DataReader reader) {<br />        for (DataPoint dataPoint : dataPoints) {<br />            reader.read(dataPoint);<br />        }<br />    }<br /></code></pre><br />We can now look at the methods we extracted. The <code>writeDataPoints</code> is all about sending data points to the data reader. The <code>DataReader</code> class already has a method for reading an individual data point. We could move the <code>writeDataPoints</code> method to the <code>DataReader</code> class and rename it to <code>read</code> to match the other <code>read</code> method. We eliminate one of the methods we just created this way. We still have <code>filterDataBlocks</code>. Right now, we can't be sure how that might evolve until we see a little more of this refactoring.<br /><br /><br /><pre><code><br />    private void loadCountyData(County county, int year, DataReader reader) {<br />        Iterable&ltDataBlock&gt; dataBlocks = county.dataBlocksFor(year);<br />        Iterable&lt;DataPoint&gt; dataPoints = filterDataBlocks(dataBlocks);<br /><br />        reader.read(dataPoints);<br />    }<br /><br />    private Iterable&lt;DataPoint&gt; filterDataBlocks(Iterable&lt;DataBlock&gt; dataBlocks) {<br />        List&lt;DataPoint&gt; dataPoints = new ArrayList&lt;&gt;();<br /><br />        for (DataBlock dataBlock : dataBlocks) {<br />            if (dataBlock.dataPoints().size() &gt;= 100) {<br />                dataPoints.addAll(dataBlock.dataPoints());<br />            }<br />        }<br /><br />        return dataPoints;<br />    }<br /></code></pre><br />Now we can do something similar at the next level up: the <code>loadStateData</code> method. It has a similar filter-and-call structure to <code>loadCountyData</code>. We can divide the two responsibilities:<br /><br /><pre><code><br />    private void loadStateData(State state, int year, DataReader reader) {<br />        Iterable&lt;County&gt; counties = state.counties();<br />        List&lt;County&gt; countiesWithData = new ArrayList&lt;&gt;();<br /><br />        for (County county : counties) {<br />            if (county.hasDataFor(year)) {<br />                countiesWithData.add(county);<br />            }<br />        }<br /><br />        for (County county : countiesWithData) {<br />            loadCountyData(county, year, reader);<br />        }<br />    }<br /></code></pre><br />We can give a name to the filtering part and extract it:<br /><br /><pre><code><br />    private void loadStateData(State state, int year, DataReader reader) {<br />        Iterable&lt;County&gt; counties = state.counties();<br />        Iterable&lt;County&gt; countiesWithData = filterCountiesWithData(counties, year);<br /><br />        for (County county : countiesWithData) {<br />            loadCountyData(county, year, reader);<br />        }<br />    }<br /><br />    private Iterable&lt;County&gt; filterCountiesWithData(Iterable&lt;County&gt; counties, int year) {<br />        List&lt;County&gt; countiesWithData = new ArrayList&lt;&gt;();<br /><br />        for (County county : counties) {<br />            if (county.hasDataFor(year)) {<br />                countiesWithData.add(county);<br />            }<br />        }<br /><br />        return countiesWithData;<br />    }<br /></code></pre><br />There seems to be a pattern developing here. We need to finish these extractions first to see it fully before we jump into creating abstractions. We can also notice that <code>loadStateData</code> is very similar to <code>loadCountyData</code>, but at one level of granularity higher. Nested calls will often be like this because each level of nesting is meant to handle one level smaller of the problem.<br /><br />Finally, we look at <code>loadNationalData</code>, and it again has a similar filter-and-call structure. We separate the two responsibilities again, and extract out the filtering (done in one step here for brevity):<br /><br /><pre><code><br />    void loadNationalData(Nation nation, int year, DataReader reader) {<br />        Iterable&lt;State&gt; states = nation.states();<br />        Iterable&lt;State&gt; participatingStates = filterParticipatingStates(states, year);<br /><br />        for (State state : participatingStates) {<br />            loadStateData(state, year, reader);<br />        }<br />    }<br /><br />    private Iterable&lt;State&gt; filterParticipatingStates(Iterable&ltState&gt; states, int year) {<br />        List&lt;State&gt; participatingStates = new ArrayList&lt;&gt;();<br /><br />        for (State state : states) {<br />            if (state.isParticipating(year)) {<br />                participatingStates.add(state);<br />            }<br />        }<br /><br />        return participatingStates;<br />    }<br /></code></pre><br />We now have a class with even more nested methods to call. We've separated the two responsibilities out of the original methods into separate methods, but that has made the original problem worse. The whole class looks like this now:<br /><br /><pre><code><br />class DataLoader {<br />    void loadNationalData(Nation nation, int year, DataReader reader) {<br />        Iterable&lt;State&gt; states = nation.states();<br />        Iterable&lt;State&gt; participatingStates = filterParticipatingStates(states, year);<br /><br />        for (State state : participatingStates) {<br />            loadStateData(state, year, reader);<br />        }<br />    }<br /><br />    private Iterable&lt;State&gt; filterParticipatingStates(Iterable&ltState&gt; states, int year) {<br />        List&lt;State&gt; participatingStates = new ArrayList&lt;&gt;();<br /><br />        for (State state : states) {<br />            if (state.isParticipating(year)) {<br />                participatingStates.add(state);<br />            }<br />        }<br /><br />        return participatingStates;<br />    }<br /><br />    private void loadStateData(State state, int year, DataReader reader) {<br />        Iterable&lt;County&gt; counties = state.counties();<br />        Iterable&lt;County&gt; countiesWithData = filterCountiesWithData(counties, year);<br /><br />        for (County county : countiesWithData) {<br />            loadCountyData(county, year, reader);<br />        }<br />    }<br /><br />    private Iterable&lt;County&gt; filterCountiesWithData(Iterable&lt;County&gt; counties, int year) {<br />        List&lt;County&gt; countiesWithData = new ArrayList&lt;&gt;();<br /><br />        for (County county : counties) {<br />            if (county.hasDataFor(year)) {<br />                countiesWithData.add(county);<br />            }<br />        }<br /><br />        return countiesWithData;<br />    }<br /><br />    private void loadCountyData(County county, int year, DataReader reader) {<br />        Iterable&ltDataBlock&gt; dataBlocks = county.dataBlocksFor(year);<br />        Iterable&lt;DataPoint&gt; dataPoints = filterDataBlocks(dataBlocks);<br /><br />        reader.read(dataPoints);<br />    }<br /><br />    private Iterable&lt;DataPoint&gt; filterDataBlocks(Iterable&lt;DataBlock&gt; dataBlocks) {<br />        List&lt;DataPoint&gt; dataPoints = new ArrayList&lt;&gt;();<br /><br />        for (DataBlock dataBlock : dataBlocks) {<br />            if (dataBlock.dataPoints().size() &gt;= 100) {<br />                dataPoints.addAll(dataBlock.dataPoints());<br />            }<br />        }<br /><br />        return dataPoints;<br />    }<br />}<br /></code></pre><br />Looking at this code in total, we can notice a few oddities that did not stick out as much before. We are passing parameters down through nested calls that don't need them except to make other nested calls, namely the <code>DataReader reader</code> and <code>int year</code> parameters. We also notice that the filter methods are actually still doing two things. They are filtering the values in a given collection, but they are also (flat) mapping them into a new collection.<br /><br />Since we still have methods with multiple responsibilities, we should separate those responsibilities out and name them. We can pull out the filtering predicates into their own methods. The result would be:<br /><br /><pre><code><br />class DataLoader {<br />    void loadNationalData(Nation nation, int year, DataReader reader) {<br />        Iterable&lt;State&gt; states = nation.states();<br />        Iterable&lt;State&gt; participatingStates = filterParticipatingStates(states);<br /><br />        for (State state : participatingStates) {<br />            loadStateData(state, year, reader);<br />        }<br />    }<br /><br />    private Iterable&lt;State&gt; filterParticipatingStates(Iterable&ltState&gt; states, int year) {<br />        List&lt;State&gt; participatingStates = new ArrayList&lt;&gt;();<br /><br />        for (State state : states) {<br />            if (isStateAcceptable(state, year)) {<br />                participatingStates.add(state);<br />            }<br />        }<br /><br />        return participatingStates;<br />    }<br /><br />    private boolean isStateAcceptable(State state, int year) {<br />        return state.isParticipating(year);<br />    }<br /><br />    private void loadStateData(State state, int year, DataReader reader) {<br />        Iterable&lt;County&gt; counties = state.counties();<br />        Iterable&lt;County&gt; countiesWithData = filterCountiesWithData(counties, year);<br /><br />        for (County county : countiesWithData) {<br />            loadCountyData(county, year, reader);<br />        }<br />    }<br /><br />    private Iterable&lt;County&gt; filterCountiesWithData(Iterable&lt;County&gt; counties, int year) {<br />        List&lt;County&gt; countiesWithData = new ArrayList&lt;&gt;();<br /><br />        for (County county : counties) {<br />            if (isCountyAcceptable(county, year)) {<br />                countiesWithData.add(county);<br />            }<br />        }<br /><br />        return countiesWithData;<br />    }<br /><br />    private boolean isCountyAcceptable(County county, int year) {<br />        return county.hasDataFor(year);<br />    }<br /><br />    private void loadCountyData(County county, int year, DataReader reader) {<br />        Iterable&ltDataBlock&gt; dataBlocks = county.dataBlocksFor(year);<br />        Iterable&lt;DataPoint&gt; dataPoints = filterDataBlocks(dataBlocks);<br /><br />        reader.read(dataPoints);<br />    }<br /><br />    private Iterable&lt;DataPoint&gt; filterDataBlocks(Iterable&lt;DataBlock&gt; dataBlocks) {<br />        List&lt;DataPoint&gt; dataPoints = new ArrayList&lt;&gt;();<br /><br />        for (DataBlock dataBlock : dataBlocks) {<br />            if (isDataBlockAcceptable(dataBlock)) {<br />                dataPoints.addAll(dataBlock.dataPoints());<br />            }<br />        }<br /><br />        return dataPoints;<br />    }<br /><br />    private boolean isDataBlockAcceptable(DataBlock dataBlock) {<br />        return dataBlock.dataPoints().size() &gt;= 100;<br />    }<br />}<br /></code></pre><br />We've made the problem even worse than before. We have methods calling methods calling methods three deep in every direction. We've separated out all of the responsibilities, and now we can make the changes that will turn the tide.<br /><br />We have three sets of three methods that each have a repeating prefix (load, filter) or repeating suffix (acceptable). When we see this happen, we know that there is a missing abstraction or two that we can create. We can start with the predicate methods (is*Acceptable). These methods might make more sense as a separate object.<br /><br /><pre><code><br />class DataFilter {<br />    private static final int MINIMUM_DATA_POINTS = 100;<br /><br />    private final int year;<br /><br />    DataFilter(int year) {<br />        this.year = year;<br />    }<br /><br />    int year() {<br />        return year;<br />    }<br /><br />    boolean isStateAcceptable(State state) {<br />        return state.isParticipating(year);<br />    }<br /><br />    boolean isCountyAcceptable(County county) {<br />        return county.hasDataFor(year);<br />    }<br /><br />    boolean isDataBlockAcceptable(DataBlock dataBlock) {<br />        return dataBlock.dataPoints().size() &gt;= MINIMUM_DATA_POINTS;<br />    }<br />}<br /></code></pre><br />We've copied out the relevant predicate methods into a separate object. The only additional changes were to extract the minimum number of data points to a constant, and to make the year a property passed in at construction. We moved the year for two reasons. First, it must be consistent between calls. By storing it, we guarantee that. Second, we reduced the number of parameters to two of the methods to just the objects they are really interested in. This object is now isolated and separately testable. Before, these methods would need to be tested through the <code>loadNationalData</code> method. Now they can be called independently with a much simpler and more direct test setup. We weave this object through our code:<br /><br /><pre><code><br />class DataLoader {<br />    void loadNationalData(Nation nation, int year, DataReader reader) {<br />        DataFilter dataFilter = new DataFilter(year);<br />        Iterable&lt;State&gt; states = nation.states();<br />        Iterable&lt;State&gt; participatingStates = filterParticipatingStates(states, dataFilter);<br /><br />        for (State state : participatingStates) {<br />            loadStateData(state, dataFilter, reader);<br />        }<br />    }<br /><br />    private Iterable&lt;State&gt; filterParticipatingStates(Iterable&ltState&gt; states, DataFilter dataFilter) {<br />        List&lt;State&gt; participatingStates = new ArrayList&lt;&gt;();<br /><br />        for (State state : states) {<br />            if (dataFilter.isStateAcceptable(state)) {<br />                participatingStates.add(state);<br />            }<br />        }<br /><br />        return participatingStates;<br />    }<br /><br />    private void loadStateData(State state, DataFilter dataFilter, DataReader reader) {<br />        Iterable&lt;County&gt; counties = state.counties();<br />        Iterable&lt;County&gt; countiesWithData = filterCountiesWithData(counties, dataFilter);<br /><br />        for (County county : countiesWithData) {<br />            loadCountyData(county, dataFilter, reader);<br />        }<br />    }<br /><br />    private Iterable&lt;County&gt; filterCountiesWithData(Iterable&lt;County&gt; counties, DataFilter dataFilter) {<br />        List&lt;County&gt; countiesWithData = new ArrayList&lt;&gt;();<br /><br />        for (County county : counties) {<br />            if (dataFilter.isCountyAcceptable(county)) {<br />                countiesWithData.add(county);<br />            }<br />        }<br /><br />        return countiesWithData;<br />    }<br /><br />    private void loadCountyData(County county, DataFilter dataFilter, DataReader reader) {<br />        Iterable&ltDataBlock&gt; dataBlocks = county.dataBlocksFor(dataFilter.year());<br />        Iterable&lt;DataPoint&gt; dataPoints = filterDataBlocks(dataBlocks, dataFilter);<br /><br />        reader.read(dataPoints);<br />    }<br /><br />    private Iterable&lt;DataPoint&gt; filterDataBlocks(Iterable&lt;DataBlock&gt; dataBlocks, DataFilter dataFilter) {<br />        List&lt;DataPoint&gt; dataPoints = new ArrayList&lt;&gt;();<br /><br />        for (DataBlock dataBlock : dataBlocks) {<br />            if (dataFilter.isDataBlockAcceptable(dataBlock)) {<br />                dataPoints.addAll(dataBlock.dataPoints());<br />            }<br />        }<br /><br />        return dataPoints;<br />    }<br />}<br /></code></pre><br />Since we've encapsulated much of what varies, we are left with duplication. The filter-and-mapping done in the <code>filter</code> methods can be more explicit by converting them to use standard <code>Stream</code> filters and maps from Java 8.<br /><br /><code><pre>class DataLoader {<br />    void loadNationalData(Nation nation, int year, DataReader reader) {<br />        final DataFilter dataFilter = new DataFilter(year);<br />        final Stream<State> states = streamOf(nation.states());<br />        final Stream<State> participatingStates = filterParticipatingStates(states, dataFilter);<br /><br />        participatingStates.forEachOrdered((state) -> loadStateData(state, dataFilter, reader));<br />    }<br /><br />    private Stream<State> filterParticipatingStates(final Stream<State> states, DataFilter dataFilter) {<br />        return states.filter(dataFilter::isStateAcceptable);<br />    }<br /><br />    private void loadStateData(State state, DataFilter dataFilter, DataReader reader) {<br />        final Stream<County> counties = streamOf(state.counties());<br />        final Stream<County> countiesWithData = filterCountiesWithData(counties, dataFilter);<br /><br />        countiesWithData.forEachOrdered((county) -> loadCountyData(county, dataFilter, reader));<br />    }<br /><br />    private Stream<County> filterCountiesWithData(final Stream<County> counties, DataFilter dataFilter) {<br />        return counties.filter(dataFilter::isCountyAcceptable);<br />    }<br /><br />    private void loadCountyData(County county, DataFilter dataFilter, DataReader reader) {<br />        final Stream<DataBlock> dataBlocks = streamOf(county.dataBlocksFor(dataFilter.year()));<br />        final Stream<DataPoint> dataPoints = filterDataBlocks(dataBlocks, dataFilter);<br /><br />        reader.read(dataPoints);<br />    }<br /><br />    private Stream<DataPoint> filterDataBlocks(final Stream<DataBlock> dataBlocks, DataFilter dataFilter) {<br />        return dataBlocks<br />            .filter(dataFilter::isDataBlockAcceptable)<br />            .flatMap((dataBlock) -> streamOf(dataBlock.dataPoints()));<br />    }<br /><br />    private static <T> Stream<T> streamOf(final Iterable<T> iterable) {<br />        return StreamSupport.stream(iterable.spliterator(), false);<br />    }<br />}<br /></pre></code><br /><br />Almost everywhere we had an <code>Iterable</code>, we've replaced it with a <code>Stream</code>. We've added a private static helper method to convert the <code>Iterable</code>s we do have into streams. We also added a new method to the <code>DataReader</code> to take a <code>Stream</code>:<br /><br /><code><pre> public void read(final Stream<DataPoint> dataPoints) {<br />  dataPoints.forEachOrdered(this::read);<br /> }<br /></pre></code><br /><br />Since the <code>filter</code> methods are much simpler, we don't need them. We can inline the filtering code into the calling methods:<br /><br /><code><pre>class DataLoader {<br />    void loadNationalData(Nation nation, int year, DataReader reader) {<br />        final DataFilter dataFilter = new DataFilter(year);<br />        final Stream<State> states = streamOf(nation.states());<br /><br />        states<br />            .filter(dataFilter::isStateAcceptable)<br />            .forEachOrdered((state) -> loadStateData(state, dataFilter, reader));<br />    }<br /><br />    private void loadStateData(State state, DataFilter dataFilter, DataReader reader) {<br />        final Stream<County> counties = streamOf(state.counties());<br /><br />        counties<br />            .filter(dataFilter::isCountyAcceptable)<br />            .forEachOrdered((county) -> loadCountyData(county, dataFilter, reader));<br />    }<br /><br />    private void loadCountyData(County county, DataFilter dataFilter, DataReader reader) {<br />        final Stream<DataBlock> dataBlocks = streamOf(county.dataBlocksFor(dataFilter.year()));<br /><br />        reader.read(dataBlocks<br />            .filter(dataFilter::isDataBlockAcceptable)<br />            .flatMap((dataBlock) -> streamOf(dataBlock.dataPoints())));<br />    }<br /><br />    private static <T> Stream<T> streamOf(final Iterable<T> iterable) {<br />        return StreamSupport.stream(iterable.spliterator(), false);<br />    }<br />}<br /></pre></code><br /><br />We are finally getting to much shorter code that is much easier to reason about. The number of nested calls is about where it was when we started. Much of the logic, though, has been moved out to more testable places. We can still tidy this up more, though. Each <code>load</code> method is now very simple, just flat mapping and filtering before calling the next method in line. We can make these steps more explicit via <code>Stream</code> methods as well:<br /><br /><code><pre>class DataLoader {<br />    void loadNationalData(Nation nation, int year, DataReader reader) {<br />        final DataFilter dataFilter = new DataFilter(year);<br />        final Stream<State> states = streamOf(nation.states());<br /><br />        reader.read(states<br />            .filter(dataFilter::isStateAcceptable)<br />            .flatMap((state) -> streamOf(state.counties()))<br />            .filter(dataFilter::isCountyAcceptable)<br />            .flatMap((county) -> streamOf(county.dataBlocksFor(dataFilter.year())))<br />            .filter(dataFilter::isDataBlockAcceptable)<br />            .flatMap((dataBlock) -> streamOf(dataBlock.dataPoints())));<br />    }<br /><br />    private static <T> Stream<T> streamOf(final Iterable<T> iterable) {<br />        return StreamSupport.stream(iterable.spliterator(), false);<br />    }<br />}<br /></pre></code><br /><br />We've finally eliminated all of the nested calls. This method is cleaner, and much simpler to understand than the original code. We can debug and test it more directly.<br /><br /><small>You can see the full progression of this code at <a href="https://bitbucket.org/cbojar-blog/nested-tangle">https://bitbucket.org/cbojar-blog/nested-tangle</a></small><br /><br /><hr/><small>This post is based on <a target="_blank" href="https://softwareengineering.stackexchange.com/q/362370">this StackExchange question</a>.</small>]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-1648455376035585358</id>
		<title>Break Down Code to Make It DRYer</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2018/01/break-down-code-to-make-it-dryer.html"/>
		<published>2018-01-11T10:59:00-05:00</published>
		<updated>2018-01-11T10:59:13-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[<a title="By Ysangkok [Public domain], via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File%3AUS_Beef_cuts.svg"><img width="256" alt="US Beef cuts" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/US_Beef_cuts.svg/256px-US_Beef_cuts.svg.png"/></a><br /><br />We are always looking to make our code <a target="_blank" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRYer</a>. Code that is not repeated is easier to maintain. We can make a change in just one place rather than hunting for different incarnations in many different places. Making code DRYer is not always easy, and sometimes how to remove the duplication is not apparent.<br /><br />Let's say we have the following two functions:<br /><br /><pre><code><br />public List&lt;Stats&gt; processLines(File file) {<br />    List&lt;Stats&gt; stats = new ArrayList&lt;&gt;();<br /><br />    for (String line : lines(file)) {<br />        Data data = extractDataFrom(line);<br />        Stats dataStats = calculateStatsFor(data);<br />        stats.add(dataStats);<br />    }<br /><br />    return stats;<br />}<br /><br />public List&lt;Stats&gt; processLines(List&lt;File&gt; files) {<br />    List&lt;Stats&gt; stats = new ArrayList&lt;&gt;();<br /><br />    int fileNumber = 0;<br />    for (File file : files) {<br />        for (String line : lines(file)) {<br />            Data data = extractDataFrom(line, fileNumber);<br />            Stats dataStats = calculateStatsFor(data);<br />            stats.add(dataStats);<br />        }<br />        fileNumber++;<br />    }<br /><br />    return stats;<br />}<br /></code></pre><br />We can immediately see that these two functions are very similar. The main difference between them is that one handles a single file while the other handles multiple files. It <em>almost</em> is the same, except for that call to <code>extractDataFrom</code>. In the first function, it takes one parameter: the line read from the file. In the second function, it takes two: the line read and the index of the file in the list of files. This means that the two methods are just different enough that they cannot be combined simply. We have to work a little harder. We can use two possible strategies for removing the duplication.<br /><br /><h2>One is a special case of many</h2>We don't see above the different implementations of <code>extractDataFrom</code>. We do know that the two overloads look like they do almost the same thing, much like the two functions we do see. Perhaps, if we scroll around in this class, we might see the following code:<br /><br /><pre><code><br />private Data extractDataFrom(String line) {<br />    extractDataFrom(line, 0);<br />}<br /><br />private Data extractDataFrom(String line, int fileNumber) {<br />    // Do some data extraction<br />}<br /></code></pre><br />This is an instance where one is a special case of many. The single file call is the same as the multi-file call with a list containing one file. Because of this, we can easily remove the duplication:<br /><br /><pre><code><br />public List&lt;Stats&gt; processLines(File file) {<br />    return processLines(Arrays.asList(file));<br />}<br /><br />public List&lt;Stats&gt; processLines(List&lt;File&gt; files) {<br />    List&lt;Stats&gt; stats = new ArrayList&lt;&gt;();<br /><br />    int fileNumber = 0;<br />    for (File file : files) {<br />        for (String line : lines(file)) {<br />            Data data = extractDataFrom(line, fileNumber);<br />            Stats dataStats = calculateStatsFor(data);<br />            stats.add(dataStats);<br />        }<br />        fileNumber++;<br />    }<br /><br />    return stats;<br />}<br /></code></pre><br />We will often see cases where one is a special case of many, and we can remove redundancy by making the one case into a many case. This often happens because we don't always see that we have these two cases that are the same. It just takes a careful eye to spot the duplication and remove it.<br /><br />Sometimes things are not that simple.<br /><br /><h2>Encapsulate What Varies</h2><br />Instead, we scroll through the file and find that the methods are defined as:<br /><br /><pre><code><br />private Data extractDataFrom(String line) {<br />    // Do some data extraction one way<br />}<br /><br />private Data extractDataFrom(String line, int fileNumber) {<br />    // Do some data extraction another, completely different way<br />}<br /></code></pre><br />The single case is not a special instance of the many case now. They are handled in different ways that must be maintained. We can't use the trick we used above. We have to look more closely at the duplication we want to get rid of.<br /><br />We first list out what our two functions are doing that overlaps:<br /><ol><li>With each file (<strong>this is done differently between the functions!</strong>)</li><li>Get each line in that file</li><li>Extract the Data from that line (<strong>this is done differently between the functions!</strong>)</li><li>Calculate the Stats for each Data</li><li>Add the Stats to the list of Stats</li><li>Return the list of Stats</li></ol><br />We see that, essentially, the steps are all the same except for the loop over the files and the extract step. Those common steps are the duplication. What we need to do now is to encapsulate what varies. Once we've encapsulated so that both functions become essentially the same, we can remove the duplication. To do this, we will need to rearrange and refactor a bit. We can make the code look like:<br /><br /><pre><code><br />public List&lt;Stats&gt; processLines(File file) {<br />    List&lt;Data&gt; datas = new ArrayList&lt;&gt;();<br /><br />    for (String line : lines(file)) {<br />        datas.add(extractDataFrom(line));<br />    }<br /><br />    List&lt;Stats&gt; stats = new ArrayList&lt;&gt;();<br /><br />    for (Data data : datas) {<br />        Stats dataStats = calculateStatsFor(data);<br />        stats.add(dataStats);<br />    }<br /><br />    return stats;<br />}<br /><br />public List&lt;Stats&gt; processLines(List&lt;File&gt; files) {<br />    List&lt;Data&gt; datas = new ArrayList&lt;&gt;();<br /><br />    int fileNumber = 0;<br />    for (File file : files) {<br />        for (String line : lines(file)) {<br />            datas.add(extractDataFrom(line, fileNumber));<br />        }<br />        fileNumber++;<br />    }<br /><br />    List&lt;Stats&gt; stats = new ArrayList&lt;&gt;();<br /><br />    for (Data data : datas) {<br />        Stats dataStats = calculateStatsFor(data);<br />        stats.add(dataStats);<br />    }<br /><br />    return stats;<br />}<br /></code></pre><br />We now have two chunks of identical code at the bottom of each function, and all of the code that varies at the top. We have started to encapsulate away the extraction of the data from lines into a simple list of datas to process the stats for. I acknowledge that there is a change in the memory performance of this code from the original, but I am going to hand-wave that for the moment and return to it later.<br /><br />Since we now have duplicate code, we can pull it out and pass in the datas as a parameter, fully encapsulating how they are derived:<br /><br /><pre><code><br />public List&lt;Stats&gt; processLines(File file) {<br />    List&lt;Data&gt; datas = new ArrayList&lt;&gt;();<br /><br />    for (String line : lines(file)) {<br />        datas.add(extractDataFrom(line));<br />    }<br /><br />    return processDatas(datas);<br />}<br /><br />public List&lt;Stats&gt; processLines(List&lt;File&gt; files) {<br />    List&lt;Data&gt; datas = new ArrayList&lt;&gt;();<br /><br />    int fileNumber = 0;<br />    for (File file : files) {<br />        for (String line : lines(file)) {<br />            datas.add(extractDataFrom(line, fileNumber));<br />        }<br />        fileNumber++;<br />    }<br /><br />    return processDatas(datas);<br />}<br /><br />private List&lt;Stats&gt; processDatas(Iterable&lt;Data&gt; datas) {<br />    List&lt;Stats&gt; stats = new ArrayList&lt;&gt;();<br /><br />    for (Data data : datas) {<br />        Stats dataStats = calculateStatsFor(data);<br />        stats.add(dataStats);<br />    }<br /><br />    return stats;<br />}<br /></code></pre><br />This is looking pretty good. The <code>processDatas</code> function takes an <code>Iterable</code> of <code>Data</code>s to be more flexible, in case we want to ever change the data structure we are using. This is an improvement, and might be good enough. However, there are still some smells with this code. First, we hand-waved the memory performance, but if the files are very large we could run out of memory where we would not have before. Second, we originally rearranged these methods by separating a unique part and a common part. This allowed us to do some encapsulation, but it also indicates that these functions may be doing to much. They may not be <a target="_blank" href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility</a>.<br /><br />We've started to encapsulate what varies by putting the <code>Data</code>s into a list, but a list doesn't fully encapsulate. It is just a general data structure for a collection of similar things. Is there a way to fully encapsulate the difference using polymorphism?<br /><br />We originally had <code>processDatas</code> take an <code>Iterable</code> to provide future flexibility. We can take advantage of that and hide the complexity of reading the files behind the simple <code>Iterable</code> interface. First, we can extract out a simple <code>Iterable</code>/<code>Iterator</code> for the single file case:<br /><br /><pre><code><br />public class SingleFileLineToDataIterable implements Iterable&lt;Data&gt; {<br />    private File file;<br /><br />    public SingleFileLineToDataIterable(File file) {<br />        this.file = file;<br />    }<br /><br />    public Iterator&lt;Data&gt; iterator() {<br />        return new SingleFileLineToDataIterator(lines(file).iterator());<br />    }<br /><br />    private static class SingleFileLineToDataIterator implements Iterator&lt;Data&gt; {<br />        private Iterator&lt;String&gt; lines;<br /><br />        public SingleFileLineToDataIterator(Iterator&lt;String&gt; lines) {<br />            this.lines = lines;<br />        }<br /><br />        public boolean hasNext() {<br />            return lines.hasNext();<br />        }<br /><br />        public Data next() {<br />            return extractDataFrom(lines.next());<br />        }<br /><br />        // Note: This method moved here from our other class<br />        private Data extractDataFrom(String line) {<br />            // Do some data extraction one way<br />        }<br />    }<br />}<br /></code></pre><br />We can create a <code>SingleFileLineToDataIterable</code> with our file and pass it to the <code>processDatas</code> function:<br /><br /><pre><code><br />public List&lt;Stats&gt; processLines(File file) {<br />    return processDatas(new SingleFileLineToDataIterable(file));<br />}<br /></code></pre><br />We can also extract out an <code>Iterable</code>/<code>Iterator</code> for the multi-file case:<br /><br /><pre><code><br />public class MultiFileLineToDataIterable implements Iterable&lt;Data&gt; {<br />    private Iterable&lt;File&gt; files;<br /><br />    public MiltiFileLineToDataIterable(Iterable&lt;File&gt; files) {<br />        this.files = files;<br />    }<br /><br />    public Iterator&lt;Data&gt; iterator() {<br />        return new MultiFileLineToDataIterator(files.iterator());<br />    }<br /><br />    private static class MultiFileLineToDataIterator implements Iterator&lt;Data&gt; {<br />        private Iterator&lt;File&gt; files;<br />        private int fileNumber = 0;<br />        private Iterator&lt;String&gt; currentLines = Collections.emptyIterator();<br /><br />        public MultiFileLineToDataIterator(Iterator&lt;File&gt; files) {<br />            this.files = files;<br />        }<br /><br />        public boolean hasNext() {<br />            if (currentLines.hasNext()) {<br />                return true;<br />            }<br /><br />            if (!files.hasNext()) {<br />                return false;<br />            }<br /><br />            currentLines = lines(files.next()).iterator();<br />            fileNumber += 1;<br /><br />            return hasNext();<br />        }<br /><br />        public Data next() {<br />            if (!hasNext()) {<br />                throw new NoSuchElementException();<br />            }<br /><br />            return extractDataFrom(currentLines.next(), fileNumber);<br />        }<br /><br />        // Note: This method moved here from our other class<br />        private Data extractDataFrom(String line, int fileNumber) {<br />            // Do some data extraction another, completely different way<br />        }<br />    }<br />}<br /></code></pre><br />We can create a <code>MultiFileLineToDataIterable</code> with our files and pass it to the <code>processDatas</code> function:<br /><br /><pre><code><br />public List&lt;Stats&gt; processLines(List&lt;File&gt; files) {<br />    processDatas(new MultiFileLineToDataIterable(files));<br />}<br /></code></pre><br />At this point, we should inline calls to both overloads of <code>processLines</code> where we can. If we can remove all the calls, we can delete them; if not, we inline what we can and mark them deprecated. In doing so, we've pushed the responsibility of reading the files out of this class completely, improving the maintainability. We've removed the duplication while encapsulating what varies. We also maintain the original memory performance reading data in the same way as we did originally.<br /><br /><hr/><small>This blog post is based on <a target="_blank" href="https://softwareengineering.stackexchange.com/q/360960/122685">this StackExchange question</a>.</small>]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-3007724840875680792</id>
		<title>Every Case Is Special</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2017/07/every-case-is-special.html"/>
		<published>2017-07-07T11:00:00-04:00</published>
		<updated>2017-07-07T11:00:20-04:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[Special cases are everywhere. This one little thing has to work this other way. Soon, there is an if/else chain twenty conditions long. Worse, that if/else chain is embedded in another chain of twelve conditions, all in one happy method. The next person making a kind of change has to tack on another condition and hope nothing blows up.<br /><br />We know it's bad when we see a bird's nest like that. How can we deal with it? Why should we? The problem with code no one understands is that no one understands it. We will have a huge problem the day it stops working. We assume that, if it works now, it will work forever. That is a faulty assumption. The world changes around us. The solid rock beneath that code can erode away. And our hair will be on fire when that day comes.<br /><br />Special cases are special. Normal cases are also special. Every case is special in some way. There are some classic special cases common to many code bases. There are quirky special cases unique to your own code. We need strategies to deal with those special cases in a maintainable way. We have to do two things: name those special cases, and encapsulate them.<br /><br /><code>null</code> is the most common special case in code. <code>null</code> is a magic thing that is nothing and can be anything. It is a cloud of anti-matter. If you touch it, it blows up in your face. We must carefully contain it everywhere. We sprinkle <code>null</code>-checks liberally throughout our code. They just make things worse. Because dealing with <code>null</code> is so common, there are strategies for dealing with it. There is the <a target="_blank" href="https://sourcemaking.com/design_patterns/null_object">Null Object</a> pattern. Instead of returning <code>null</code>, we return an object of the correct type but with default or empty behavior. We name a thing to represent nothing, and then we encapsulate its nothingness. The calling code is none-the-wiser, but much happier without checking for <code>null</code>.<br /><br />There are other common special cases. There's the "old way/new way." We were doing something in the code. One day, we need to do something else, but we still need to do the old thing too. We wrapped them up in a conditional and switched on a flag between them. We now have two things. They might be radically different. They might share a chunk of logic. But we don't have a name for them, and we haven't encapsulated them. When we need to add the "new new way," we're going have to work it into that conditional. Instead, we can extract classes to represent the two ways. We can tweak them so that they have the same interface. Then we can encapsulate them away behind simple logic that knows which one to pick. The two ways are not just random conditional bits of code. They are first-class objects with names that can be referenced and discussed. They are encapsulated so that changing them or adding a new way is much less risky.<br /><br />By naming and encapsulating special cases, we can treat them just like the normal cases. By doing so, we reduce the risk of introducing unstable conditional code. We can deal with all cases at their level of abstraction while not cluttering up the calling code. We get all the tools of object-oriented design to improve those special cases because they are isolated. Treating every case as special, worthy of a name and a place, makes our code better.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-986102587080832720</id>
		<title>Making Wrong Code Be Wrong</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2017/06/making-wrong-code-be-wrong.html"/>
		<published>2017-06-22T11:00:00-04:00</published>
		<updated>2017-06-22T11:00:16-04:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[I was recently perusing when I came across a link to a <a target="blank" href="https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/">Joel Spolsky blog post</a>. In it, he describes how a form of Hungarian notation can be used to make wrong code look wrong. In the process, he describes the interesting history of how Hungarian notation came to be, and how the common use of it today was not the way it was originally intended.<br /><br />He describes how Hungarian notation was created to convey application-level information about a variable. It could be used to distinguish between two different types of dimensions that might both be typed as <code>int</code>s. He termed this Apps Hungarian. While the compiler could not tell them apart, the human eye would be able to with a cursory glance. Later, the notation was instead conflated with the type that the compiler saw. An <code>int iWidth</code> carried redundant information that could actually <em>get in the way</em> if the type ever needed to change. He termed this Systems Hungarian.<br /><br />He gives several examples in the post. Notably, he describes how Apps Hungarian can be used to distinguish between unsafe strings from user input, and safe strings that have been sanitized or strings that are in the code. So <code>String usName = Request("usName")</code> would represent an unsafe string provided by a user through a form. And <code>String sName = Encode(usName)</code> would represent a string that has been sanitized. These names are Hungarian because they use one- or two-letter prefixes to provide additional information, but we could change them slightly. The names <code>unsafeName</code> and <code>safeName</code> use full, descriptive words in place of the prefixes. We could say they just have longer prefixes, but more generally I think we'd agree that these variables are just named well.<br /><br />The problem with Apps Hungarian is that it still requires a human eye. Whatever their names, <code>safeName</code> and <code>unsafeName</code> are still just strings to the compiler. We can still make subtle mistakes, even with the conventions in mind. Can we do better than relying on human vigilance? The issue with Systems Hungarian is that it duplicates type information. Perhaps Apps Hungarian is doing the same in a way. What if it is still encoding type information, but for types we haven't created yet?<br /><br />Using the HTTP request example (and modifying it to make it more correct Java), we would have the following with Apps Hungarian:<br /><br /><pre><code><br />// I am making up a web framework, so this isn't exactly any particular API.<br />public void doPost(HTTPRequest request, HTTPResponse response) {<br />    String usName = request.getData("usName");<br /><br />    // Do some stuff...<br /><br />    names.save(usName);<br /><br />    // Do some more stuff...<br /><br />    String sName = HTML.encode(usName);<br /><br />    // Do even more stuff...<br /><br />    response.write(usName);<br />}<br /></code></pre><br />Now the quick eye will note that I made a mistake in the last line. I am printing out the unsafe string rather than the safe one. Once this gets to code review, someone should spot this pretty quickly. Getting to code review is a comparatively long way away from the moment when this code was written, though. Can we get the code to <em>be</em> wrong sooner? Why don't we start by creating a small type for unsafe strings:<br /><br /><pre><code><br />public class UnsafeString {<br />    private final String unsafeString;<br /><br />    public UnsafeString(final String unsafeString) {<br />        this.unsafeString = unsafeString;<br />    }<br /><br />    public String toString() {<br />        return unsafeString;<br />    }<br /><br />    public String toSafeString() {<br />        return HTML.encode(unsafeString);<br />    }<br />}<br /></code></pre><br />Now the above code looks like:<br /><br /><pre><code><br />public void doPost(HTTPRequest request, HTTPResponse response) {<br />    UnsafeString usName = new UnsafeString(request.getData("usName"));<br /><br />    // Do some stuff...<br /><br />    names.save(usName.toString());<br /><br />    // Do some more stuff...<br /><br />    String sName = usName.toSafeString();<br /><br />    // Do even more stuff...<br /><br />    response.write(usName); // Compiler error!!<br />    response.write(sName); // But this is fine<br />}<br /></code></pre><br />Instead of having to wait until code review to see that I used the wrong variable, the compiler immediately complains because the type of the parameter is incorrect. The <code>response.write</code> method is expecting a <code>String</code>, but is getting an <code>UnsafeString</code>. We are using the power of the compiler and the type system to find our bugs for us automatically. Now, though, we could forget to wrap every user input in an <code>UnsafeString</code>, leading us back down the wrong path. What if we have the <code>request.getData</code> method always return us an <code>UnsafeString</code>?<br /><br /><pre><code><br />public class SafeHTTPRequest {<br />    private final HTTPRequest request;<br /><br />    public SafeHTTPRequest(final HTTPRequest request) {<br />        this.request = request;<br />    }<br /><br />    public UnsafeString getData(final String name) {<br />        return new UnsafeData(request.getData(name));<br />    }<br /><br />    // Other delegate methods to emulate an HTTPRequest<br />}<br /></code></pre><br />And our code changes to:<br /><br /><pre><code><br />public void doPost(SafeHTTPRequest request, HTTPResponse response) {<br />    UnsafeString usName = request.getData("usName");<br /><br />    // Do some stuff...<br /><br />    names.save(usName.toString());<br /><br />    // Do some more stuff...<br /><br />    String sName = usName.toSafeString();<br /><br />    // Do even more stuff...<br /><br />    response.write(usName); // Compiler error!!<br />    response.write(sName); // But this is fine<br />}<br /></code></pre><br />Now the code makes it much more difficult for us to do the wrong thing. We <strong>must</strong> handle the unsafeness of the string. We are still making some assumptions, though. We are correctly assuming that an <code>UnsafeString</code> is unsafe, but we are implicitly assuming that a plain <code>String</code> is always safe. This may be a good assumption, or it may not be. Rather than assume the best, let's make things explicit. We will add a counterpart <code>SafeString</code> type:<br /><br /><pre><code><br />public class SafeString {<br />    private final String safeString;<br /><br />    public SafeString(final String safeString) {<br />        this.safeString = safeString;<br />    }<br /><br />    public String toString() {<br />        return safeString;<br />    }<br />}<br /></code></pre><br />We change <code>UnsafeString</code> to convert to a <code>SafeString</code> instead of a <code>String</code>:<br /><br /><pre><code><br />public class UnsafeString {<br />    private final String unsafeString;<br /><br />    public UnsafeString(final String unsafeString) {<br />        this.unsafeString = unsafeString;<br />    }<br /><br />    public String toString() {<br />        return unsafeString;<br />    }<br /><br />    public SafeString toSafeString() {<br />        return new SafeString(HTML.encode(unsafeString));<br />    }<br />}<br /></code></pre><br />And our top-level code looks like:<br /><br /><pre><code><br />public void doPost(SafeHTTPRequest request, HTTPResponse response) {<br />    UnsafeString usName = request.getData("usName");<br /><br />    // Do some stuff...<br /><br />    names.save(usName.toString());<br /><br />    // Do some more stuff...<br /><br />    SafeString sName = usName.toSafeString();<br /><br />    // Do even more stuff...<br /><br />    response.write(usName); // Compiler error!!<br />    response.write(sName); // Also a compiler error!!<br />}<br /></code></pre><br />Now we have a problem that we can no longer write anything out without converting it using <code>toString</code>, and doing that would defeat the compiler checks we purposely put in place. Since we've already customized the request to give us <code>UnsafeString</code>s, we can customize the response to take only <code>SafeString</code>s:<br /><br /><pre><code><br />public class SafeHTTPResponse {<br />    private final HTTPResponse response;<br /><br />    public SafeHTTPResonse(final HTTPResponse response) {<br />        this.response = response;<br />    }<br /><br />    public void write(final SafeString value) {<br />        response.write(value.toString());<br />    }<br /><br />    // Other delegate methods to emulate an HTTPResponse<br />}<br /></code></pre><br />Our top-level code now takes a <code>SafeHTTPResponse</code>:<br /><br /><pre><code><br />public void doPost(SafeHTTPRequest request, SafeHTTPResponse response) {<br />    UnsafeString usName = request.getData("usName");<br /><br />    // Do some stuff...<br /><br />    names.save(usName.toString());<br /><br />    // Do some more stuff...<br /><br />    SafeString sName = usName.toSafeString();<br /><br />    // Do even more stuff...<br /><br />    response.write(usName); // Compiler error!!<br />    response.write(sName); // This is now assuredly fine<br />}<br /></code></pre><br />We now have the compiler doing all of the error-finding for us. This is the ideal position to be in. It will detect our errors, and the wrong code will <em>be</em> wrong, immediately. These small objects save the day for us by making explicit what once was implicit in a variable name. Now, the prefixes have become redundant with the type, transforming from Apps Hungarian to Systems Hungarian. We can continue to use the type system to clean this up more. We could add an overload <code>write(UnsafeString)</code> to <code>SafeHTTPResponse</code> that would convert the parameter to a <code>SafeString</code> before writing it. Then we'd only ever need the single value and we could pass it without any error everywhere, while still having strong assurances that it is doing the right thing.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-4539929901654670623</id>
		<title>Bug Hunts: Better Together</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2017/06/bug-hunts-better-together.html"/>
		<published>2017-06-08T11:00:00-04:00</published>
		<updated>2017-06-08T11:00:02-04:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[Bugs are demoralizing. Bugs are draining. Bugs are frustrating. Bugs suck.<br /><br />Nobody really wants to have bugs, and nobody really wants to be the one who has to track them down. Bugs are a reality of software development. They happen in even the most meticulously managed software. They always seem to come from the obscure or not-understood part of the code. They give error messages that make no sense and are completely unhelpful. I'm looking at you, <code>NullPointerException</code> and equivalents.<br /><br />Getting assigned bug tickets is the software development equivalent to latrine duty. It is a necessary task that needs done, but no one wants to do it. A developer could spend hours or even days banging their head on their desk just trying to figure out what could possibly be causing the error. All the while, they are not creating new business value.<br /><br />For some team members, finding where the bug is coming from is easiest. For others, discovering what is causing the software to get into a bad state in that location is a specialty. For yet others, knowing how to fix the bug is their particular skill. But rarely does one team member have the deep knowledge needed to find and fix any given bug on their own. The problem is particularly chronic in a large, convoluted legacy code base.<br /><br />Can we make bug hunting any better? If different team members each have the different necessary skills, we could go on bug hunts together instead. Rather than a single developer struggling to find the fix, the whole team can put their heads together to squash the problem at hand. By bringing each of their respective skills, bugs can be corrected faster and better than a single developer might do on their own.<br /><br /><a target="blank" href="https://en.wikipedia.org/wiki/Linus%27s_Law">With more eyeballs, the bugs become shallower.</a> But there's more to it than just that. A single person struggling becomes demoralized and drained. Together, team members can support each other. At the very least, one person doesn't feel so silly if other people are struggling too. The team forms a loop of positive reinforcement. The team also shares knowledge about the buggy part of the code as they reason through the problem. Unclear parts are questioned, and tricky parts are brought to the surface for refactoring.<br /><br />Bug hunts are better together. Not only are bugs more easily fixed by a group, but the team gets better by the experience. ]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-7711168153372467588</id>
		<title>Change the Wrong Way</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2017/05/change-wrong-way.html"/>
		<published>2017-05-25T11:00:00-04:00</published>
		<updated>2017-05-25T11:00:29-04:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[Many factors can force software to change, such as new business requirements or new technology requirements. As software developers, we have to handle the constant stream of new demands in a maintainable way. But sometimes we don't have the time, or we don't have the resources. We just need to make it work because <em>they need it <strong>like yesterday!</strong></em> When we allow ourselves to get caught up in the frenzy, we let quality slip. Other times, we just didn't know. Or we had bad practices that we thought were fine. Quality slips all the same. Can we see these issues just by looking at the code?<br /><br /><pre><code>public List<Person> getPersons(String name, String firstName, int contacts, boolean sort,<br />    boolean dir) {<br />  ResultSet rs;<br />  List<Person> persons = new ArrayList<person>();<br />  if (name != null) {<br />    rs = db.query("SELECT * FROM People");<br />    addAllPersons(rs, persons);<br />    if (sort) Collections.sort(persons);<br />    if (dir)<br />      return persons;<br />  } else {<br />    rs = db.query("SELECT * FROM People WHERE last_name = ? " +<br />      (firstName != null ? " AND first_name = ?" : ""),<br />      Arrays.asList(name, firstName).stream().filter(Objects::nonNull)<br />        .collect(Collectors.toList()).toArray());<br /><br />    addAllPersons(rs, persons);<br /><br />    if (contacts > 0) {<br />      rs = db.query("SELECT People.* FROM People JOIN Contacts ON " +<br />        "Contacts.person_id = People.id WHERE Contacts.contact_id IN (" +<br />        String.join(",", getPersonsIds(persons)) + ")");<br />      addAllPersons(rs, persons);<br />    }<br /><br />    if (sort) {<br />      Collections.sort(persons);<br />    }<br />  }<br /><br />  if(!dir) {<br />    Collections.reverse(persons);<br />  }<br /><br />  return persons;<br />}<br /></code></pre><br />This method exhibits change gone wrong. It's bad. We can see how it grew over time. We started with a method to get all the people in the database. Then one day, we just needed to filter by name, but also still get all the people if we wanted to. This is the first step down the wrong path. These should have been two separate methods, but we just needed this to work. Now we may have calls like the following sprinkled throughout the code:<br /><br /><pre><code><br />people.getPersons(null, null, -1, false, true);<br />// ...<br />people.getPersons("Smith", null, 1, true, true);<br />// ...<br />people.getPersons("Spector", "Jim", 6, false, true);<br /></code></pre><br />Looking at the invocations, we cannot know the meanings of the different parameters. We might guess the first two are names based on the last call, but we couldn't know that in the first call. Our IDE can show us what the names of the parameters are, but sometimes even that doesn't help. What does the boolean <code>dir</code> mean without looking at the implementation? If we realize it means sort direction, is <code>true</code> ascending or descending? And what does it do if we aren't sorting?<br /><br />A significant number of calls explicitly pass in a <code>null</code> for a parameter to completely switch behavior, telling us there is a lot going on. The <code>name</code> and <code>firstName</code> parameters of the method above have several explicit <code>null</code>s passed in as their values to change the searching behavior. Their values also determine if the <code>contacts</code> parameter is used. Passing explicit booleans is also a smell. If we know the value of the boolean parameter, then we are able to call a more semantic method right there at compile time.<br /><br />The issue at hand is not how to fix the above code. Any decent software developer would be able to imagine one of the many ways to accomplish that. The real question is why code ends up looking like this. The developers who make these changes <strong>think they are doing the right thing</strong>. They don't realize that they are making the code <em>less</em> flexible, not more. In the above method, searching, sorting, and finding contacts are tied together. Trying to use just one of those features requires knowing exactly the right combination of flags. But the way they see it, searching and sorting should go together like peanut butter and chocolate. After all, it reduces duplication! There are not a number of sort calls all over the place. Instead, it is just inside this one method. They fail to realize they've introduced a new duplication in many more places. We now have to duplicate the knowledge that the boolean parameter means "sort" to <em>every</em> call to the method, including the ones that don't sort.<br /><br />Sometimes it isn't just a single developer. There may be an entire team or an entire organization unaware of (or complicit in) the quality issues being created. Even a developer who knows better may give in because the world is against them. But one day, it all comes crashing down. Suddenly all the business people want to know why it is so hard just to make it sort by first name in this one case. A mountain of technical debt comes due. The quality issues become apparent to everyone, rotting from the inside out. Had there been a focus on quality, it wouldn't have turned out that way.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-3600754627921788885</id>
		<title>Frameworks of Failure</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2017/05/frameworks-of-failure.html"/>
		<published>2017-05-05T10:58:00-04:00</published>
		<updated>2017-05-11T08:48:48-04:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[As programmers, we are always seeking to match great problems to elegant solutions. We want to solve a problem in a way that solves it forever. The larger the problem is, the greater our need to find that permanent solution. This thinking is what leads us to create hulking pieces of software that try to solve every problem but solve no problem well. These frameworks we create aim to be general enough to apply to an entire category, but lack the concrete details to be applicable to any specific need.<br /><br />We build these frameworks because building them is more interesting than the actual problem we have to solve. Who wants to write the software to track auto parts in a warehouse when we could write a framework that maps relational data to object workflows? We could use that framework on <em>any</em> problem like that. We just need to add tens of thousands more lines of code tightly coupled to our framework. Too bad all we end up writing is a giant framework and a giant business logic layer to... track auto parts in a warehouse.<br /><br />We mean well. It's not that we just want to complicate things. We actually intend to make things <em>easier</em> with a framework. We try to decouple the solution from the problem. We see a pattern and we wrap that up so we only deal with that once. Until we find out that the pattern wasn't really quite the pattern we thought it was. Maybe it wasn't even a pattern at all. We can just adjust the framework, tweak a few things, and now it works again. No problem, right?<br /><br />We are trained to spot the patterns by everything that brings us into software development. We should spot patterns in mathematics. We should spot duplication in code. We should even group people based on similarities such as appearance or political opinion. We should see the pattern in everything because how can we live if we ever have to do the same thing twice? I've actually heard a developer ask a client, "But what is the general problem?"<br /><br />Customers don't know what the general problem is. There may not even be a general problem to have. They may truly want something that is only used one way. Then the next day they may discover they need to use that something a completely different way. But until the next day, they don't know.<br /><br />Customer problems are emergent. They are discovered in the course of business and cannot be enumerated on the first day. Internal and external factor drive their needs from moment to moment. Because the problems are emergent, our solutions should be emergent as well. We need to design the code in such a way that we can transform it to the next form it needs to be.<br /><br />I've even fallen into this myself. The client asked me if I could put a message on their home page wishing visitors a merry Christmas. This was on a bit of short notice, two weeks before at most. I took this as a problem in need of a general solution, a framework for displaying message widgets on the site on any page. It was a clever framework, pulling in widget configurations for different message widgets. After all, there were so many holidays, and there might even be other types of messages to display. By the time I got it done in January, though, it didn't matter how clever it was. And I never had to display another message.<br /><br />The simpler solution was to just edit the page content and put it in there. When it was no longer needed, I could simply remove it. I got caught up in a framework frenzy. I eventually removed the whole thing in a later code reorganization. I also learned to stop and think before I jumped to building another framework.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-1601410223061932930</id>
		<title>The 7 Worst Atrocities of Cleverness</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2017/04/the-7-worst-atrocities-of-cleverness.html"/>
		<published>2017-04-20T11:00:00-04:00</published>
		<updated>2017-04-20T11:00:07-04:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[We know we <a href="http://blog.cbojar.net/2017/02/dont-be-clever.html">shouldn't be clever</a>, but what is clever? There are seven particularly bad forms of cleverness, from very small to very large.<br /><br /><h2>Bitwise Logic and Ternary Statements</h2><br />This is the lowest-level cleverness. We write a one-liner that uses bitwise logic or a ternary statement. They start out innocently. We have an assignment based on a simple condition. A full-blown <code>if-else</code> block feels like overkill. Then that turns into this:<br /><br /><code><pre>int i = 16 + (!(a & 4 == 0 ? thing : other).getValue().equals(b & 1 == 0 ? first : last) ^<br />    (b & 2 != 0 ? w[0][1] : w[0][0])) ? counter - 1 : counter << 1;<br /></pre></code> That's not clever. That's a train wreck.  <h2>Singletons and Lying About Dependencies</h2>Design patterns are general solutions to common problems, and are often useful. But <a target="_blank" href="https://sourcemaking.com/design_patterns/singleton">Singleton</a> is one "pattern" (actually an <a target="_blank" href="https://code.google.com/archive/p/google-singleton-detector/wikis/WhySingletonsAreControversial.wiki">anti-pattern</a>) that can be destructive to a codebase. Singletons are easy to write and easy to use, but they are just another form of global state. Programmers who don't understand this will use them everywhere for everything, tightly coupling their code to this global state. Singletons hide large dependencies in seemingly innocuous calls. For example:  <code><pre>public String getURLFor(String name) {<br />    Database db = App.getDatabase();<br />    ResultSet rs = db.query("SELECT url FROM Urls WHERE name = ?", name);<br />    return rs.getRow(0).getString("url");<br />}<br /></pre></code> From the outside, this looks like a straightforward method, but the method interface is deceptive. A database Singleton is conjured from the global state. An expensive database query maps the name to a URL. There is no way to test this easily, or to substitute that dependency.   <h2>Subverting the Type System</h2>We make a conscious choice to work in statically-typed languages like Java or C#. We accept that the code will be more verbose and more complex. We do it for the benefit of having stronger compile-time assurances that our code is correct. Sometimes we feel writing out the type of every variable, parameter, and return type is a bit onerous. We will even feel that forcing one part of the code to know every type is restricting. We could instead pass around <code>Object</code>s and cast everywhere. This cleverness, of course, loses compile-time assurances the language writers worked to preserve. We eventually need to know the types we are dealing with. So we embed implicit knowledge of type across the code base in a completely haphazard manner as casts and <code>instanceof</code> operations. We must always be on guard in case we receive an object of an unexpected type.  <code><pre>public Object getValue(Object key) {<br />    if (key instanceof String) {<br />        return stringKeyedMap.get(key);<br />    } else if (key instanceof Long) {<br />        return longKeyedMap.get(key);<br />    } else if (key instanceof Date) {<br />        return dateKeyedMap.get(key);<br />    } else {<br />        return null;<br />    }<br />}<br /><br />// Meanwhile, elsewhere in the code<br />Object key = thingy.getKey();<br />String value = ((String)mappings.getValue(key)).trim();<br /></pre></code> Why is that a <code>String</code>? How do we know? It simply is what it is. Any change could break everything, and we'd only find out at runtime. This seems like a clever way around types at first, but it turns out to be a source of bugs and errors.  <h2>Code as Configuration</h2><p>Configuration, a set of values in a file or database table, are a way to adjust the behavior of a system outside of the code. Configuration as key-value pairs or a slightly richer hierarchy of values is simple to use in code. It can be edited by end users without too much effort. There's no logic in that kind of configuration. There are no conditionals. As soon as the idea of a conditional is introduced, it goes from being configuration to being code.</p><p>Once configuration contains conditionals, it is no longer simply a manifest of data. It has embedded logic, and it won't be long until loops and even more powerful idioms tag along. The configuration may evolve to take advantage of an existing language, like Javascript, but modifying it to its own special needs. Or it may evolve into its own separate beast of a language. As it grows, more of the program flow control will live outside of the code itself.</p><p>Code as configuration promises greater flexibility and end-user pliability. Instead of paying real developers to make these complex changes, we can hire "configurators" to write these rules instead. These rules grow to a complexity so great that they require a real developer to write and maintain.</p><p>Code belongs in the code base. There it can be tracked, controlled, searched, managed, integrated, and maintained. Tools can be used to gain insight and understanding of code, but not of external configuration. Because the configuration language is often non-standard, developers cannot reach for any of the tools that they use on code. Clever developers will move large chunks of business logic into "configuration" to make the application more flexible, but lose visibility into that logic.</p><h2>Everything, Absolutely Everything in the Database</h2><p>Databases are powerful stores for many different types of data. We can store groups of data into tables, and relate data in different tables to each other through foreign key relationships. Databases can perform well under stress with tens of gigabytes inside them. This power is enticing to the clever developer. If the database can store so much arbitrary structured data, how much can we put in there?</p><p>The cleverest developers can find ways to put just about everything inside of a database. Soon, tables holding application data are rubbing elbows with tables holding environment configuration, SQL queries, scheduled calls, and even chunks of code. As more of this non-data finds its way into the database, the application becomes more difficult to manage. Constant calls to the database slow the system down. To see some parts of the application require making slow queries against a remote database instead of fast grepping through local files. Visibility into that code decreases. Version control is hampered since swaths of the code can no longer be tracked as local files. Upgrades become hair-raising adventures of ensuring that the database was not corrupted.</p><p>While once again the clever developer promises flexibility, the code instead becomes less flexible.</p><h2>Solve Every Problem</h2><p>Line-of-business apps are boring. Who wants to learn all about how to sell car parts or how to do double-entry bookkeeping? Not the clever developer. In their mind, there are bigger problems to solve, and they can write the software to solve every problem!</p><p>The problem with solving every problem is that they won't solve any problem well. Instead, we end up with frameworks and engines and workflows that are poor abstractions for any particular use. Writing a system to encompass an entire problem set is a massive undertaking. It is also a useless undertaking. An application focused on business needs is smaller, faster, and easier to maintain. </p><h2>We're Different</h2><p>Every developer and business wants to believe they are a special snowflake. Everyone should have something special about them, but too many feel like everything is special about them. Their code, their organizational structure, their process, and their communications are needlessly unique. They reinvent a lot of wheels in code. They create byzantine processes to ensure quality, but that actually just slow things down and make things worse. Even when adopting something from the outside world, they tweak it and and bend it and contort it until all of the benefits are lost.</p><p>The uniqueness weighs on every aspect. Talent is harder to acquire because they cannot be familiar with the systems. Changes are harder to make because a unique process has a limited pool of experience to improve with. Communications are harder because of vocabulary that doesn't quite mean what everyone else would think it means. Progress is hard because the group is organized and run by fiat.</p><p>Not all "tried and true" methods are good for every organization, but they generally have years of real-world testing behind them. Many of them have the support of academic study as well. By leveraging this accumulated understanding, a group can be properly organized to meet its needs without having to reinvent the wheel blindfolded.</p><h2>Bonus! The Compound Sin</h2><p>Each of these atrocities of cleverness is bad enough on its own, but their awfulness multiplies when they are used together. Imagine a system developed with all unique components to solve a general problem like "workflow." Much of the "configuration" that is actually code is stored in the database. When those bits of code are pulled out, they are "type independent," pretty much doing everything with <code>Object</code>s and casting so that we can pull any type we want out of the database. We store some chunks in cached singletons so they can be used anywhere without needing to pass them around or go to the database again. And because we are so clever, we throw in a lot of ternary statements to keep down the lines of code.</p><p>This program is an unmaintainable mess. It doesn't <em>do anything</em>. It likely doesn't even run without a significant amount of configuration already in the database. It is an oddity, admired for its cleverness but not for its usefulness.</p>]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-3336524550395625482</id>
		<title>Don&apos;t Be Clever</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2017/02/dont-be-clever.html"/>
		<published>2017-02-24T11:00:00-05:00</published>
		<updated>2017-02-24T11:00:09-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[I was recently watching <a target="_blank" href="https://www.youtube.com/watch?v=X2F2uIKCeRs">a talk by Dan North</a>. At one point he briefly talks about a project he worked on. For this project, the Ant build script was generated with an XSLT transform, producing a build script about 2 million lines long. Even though that is clearly horrible, my first fleeting thought was, <q>Huh, I would have never thought to do that. That's pretty clever.</q>.<br /><figure><br /><iframe width="560" height="315" src="https://www.youtube.com/embed/X2F2uIKCeRs?start=117" frameborder="0" allowfullscreen></iframe><br /><figcaption>Dan North's <i>Simplicity, the Way of the Unusual Architect</i>, at the time of the story</figcaption><br /></figure><br /><q>That's pretty clever,</q> is absolutely the <em>wrong</em> thought to have. I cannot fathom the monumental, wasted effort maintaining such a system. But I am also sure it started as someone's clever idea. There would be plenty out there who would say, <q>Well, <em>that</em> project went wrong, but the idea itself isn't bad. It's pretty darn clever, really.</q><br /><br />"Cleverness" like that always seems promising at first. It is a novel view of a problem at hand. Because clever ideas are novel in completely unexpected ways, they have unexpected consequences. Once in place, they become <em>entrenched</em> in the structure. Just implementing those ideas was an undertaking because of their cleverness. Throwing that all away is not an option. Keeping them working under evolving circumstances requires layering on additional cleverness. It all looks like a precarious game of Jenga. There are quirks to build around. There are blocks never to be touched.<br /><br />Brian Kernighan said, <q>Everyone knows that debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it?</q> Those of us who are not clever enough are trapped. We plod through the complexity just trying not to break anything. Most importantly, we will all end up not being clever enough eventually.<br /><br />We all seem to admire cleverness, despite its dark side. From a young age, we are praised for our cleverness. It becomes an admirable trait. Cleverness "on the computer" might even be why we do what we do. That's why we momentarily admire horrifying things, like XSLT transforming Ant scripts. Cleverness is not intelligence, though. We can be smart without doing clever things.<br /><br />Smart people like to be challenged. Being clever is one sort of challenge, but there are others. A better challenge is to be dull. Think of the most boring, straightforward way of doing something. Make it just flexible enough, but don't over engineer. If it is simple enough for a brand new software developer to understand, you've achieved your goal. When you produce software that dull, you produce software that is maintainable, software that is able to evolve.<br />]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-8466637225473770866</id>
		<title>Stand Up Against Stand Ups</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2017/01/stand-up-against-stand-ups.html"/>
		<published>2017-01-19T11:00:00-05:00</published>
		<updated>2017-01-19T11:00:26-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[It's finally happening: your team is finally going <em><q>Agile,</q></em> whatever that means. The business has complained for too long. The team has complained for too long. You need to move faster and do more. Word comes down that you're going to try <strong>Scrum</strong>. This shouldn't be too bad. After all, <a target="_blank" href="http://www.scrumguides.org/scrum-guide.html">Scrum can't be that hard to master</a>. Well, turns out that there's a lot to Scrum, and your team can't just switch over in one day! Let's take this slowly, adding in the simple parts and going from there. Timeboxed iterations make sense. Your team already has a weekly meeting, so sprints are a week. That was pretty easy. What's next? Product owner, no; retrospectives, no; story points, no. Aha, stand-ups! Once every day, you stand up and talk about stuff. That's easy enough. Done. You are so Scrummy now!<br /><br />Or not so much. That all-too-common story of <q>Agile Transformation</q> highlights a number of pitfalls that derail real change. The most deceptive practice, though, is the daily stand-up. The daily stand-up is one of those Agile things that is very visible and very tangible. A team physically moves from their desks, stands in a designated place, and talks in a circle for several minutes. Management can <em>see</em> and <em>hear</em> them move and stand and talk. But a <strong>good</strong> stand-up is more than just moving and standing and talking.<br /><br />The biggest deception of stand-ups is that they're really just meetings. People will say they hate meetings but love stand-ups, not realizing they are praising <em>a meeting they have to attend every single day</em>. Because stand-ups are meetings, they suffer from <a target="_blank" href="https://m.signalvnoise.com/status-meetings-are-the-scourge-39f49267ca90">many of the same drawbacks as any other meeting</a>. They are synchronous. <a target="_blank" href="http://lifehacker.com/how-long-it-takes-to-get-back-on-track-after-a-distract-1720708353">They are interruptions.</a> They are, in part or whole, not equally valuable to everyone that must attend. The combined <em>hours</em> of lost productivity every day adds up.<br /><br />Good stand-ups might be worth the costs, but bad stand-ups are simply drains on the team and the business. What distinguishes a good stand-up from a bad one? I take a page out of the <a target="_blank" href="https://youtu.be/CKWvmiY7f_g?t=44m2s">Kanban book</a>: good stand-ups are brief, and they are only about blocking issues. They don't involve discussion, sidebars, announcements, or even solutions for the blockers (unless the solutions are really simple). <em>And they definitely don't include status.</em> Status should be reported elsewhere, either on a board tracking work, in a system like JIRA, or wherever else communicates that information. Because of the difficulty, good stand-ups are expert-level Agile. Teams just starting out should not jump to stand-ups.<br /><br />This assertion opens the question of what should a team start with if they are moving to Agile? Timeboxing is an easy step, though getting it right-sized is also deceptively difficult. Designating a product owner can go a long way in aligning priorities with the business and users, but can be exceedingly difficult to get someone to commit to. The two practices I believe are both achievable and most effective at improving things are story point estimation and retrospectives.<br /><br />Story point estimation is <a target="_blank" href="https://en.wikipedia.org/wiki/Planning_poker">easy to do</a>. The team can integrate it as part of the weekly meeting. Even making bad estimates is useful because it shows where the team is under- or overestimating effort. More importantly, story point estimation forms the basis of <a target="_blank" href="https://www.atlassian.com/agile/metrics">numerous valuable metrics</a>, facilitating both better future planning and better future estimation.<br /><br />Retrospectives are not the easiest to get in place. They are another meeting. It also takes some skill to keep a retrospective from becoming a <a target="_blank" href="http://www.dictionary.com/browse/blamestorming">blamestorming</a> session. Effective retrospectives will bring hidden and unexpected issues to the forefront that would otherwise quietly sap performance and productivity. At the same time, they will build trust and confidence in the members of the team.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-8239569054025218963</id>
		<title>Exposing Dependencies: Getting Worse Before Getting Better</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2017/01/exposing-dependencies-getting-worse.html"/>
		<published>2017-01-05T11:00:00-05:00</published>
		<updated>2017-01-05T11:00:00-05:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[As software developers, our job is managing dependencies. We have to carefully construct balanced graphs of classes, objects, libraries, services, and more. Code needs to be encapsulated, reusable, and extensible, all while creating end-user value. We use techniques like composition, inheritance, and dependency injection to separate this from that, knowing that this or that could change in unknown ways at any moment.<br /><br />We don't always get to create the perfect system from the ground up though. Sometimes, we work on software developed long ago that could not anticipate today's needs. It hurts a little more when we see our name on all those commit messages. Regardless, we need to make the necessary adjustments for our system to meet the needs of today and tomorrow. To make code more flexible and adaptable, we often have to break it up into more singular and discrete responsibilities. We have to pull out and encapsulate the pieces that are at different levels of abstraction. We have to control those dependencies, so they don't end up controlling us.<br /><br />Say we have the following code from an application that does analysis on text:<br /><br /><code><pre>/**<br /> * Show words and their counts imported between the dates specified.<br /> */<br />public void showWordCountsInRange() {<br />    JWordViewer wordViewer = App.getGUI().getActiveWordViewer();<br />    Database db = App.getDB();<br />    ResultSet rs = db.query("SELECT word, COUNT(word) AS word_count FROM Words WHERE " +<br />        "import_date >= " + DBUtils.toSQLString(wordViewer.getStartField().getDate()) + " AND " +<br />        "import_date < " + DBUtils.toSQLString(wordViewer.getEndField().getDate()) + " " +<br />        "GROUP BY word");<br /><br />    Map<String, Long> words = new HashMap<>();<br /><br />    for(Result result : resultSet) {<br />       words.add(result.getString("word"), result.getLong("word_count"));<br />    }<br /><br />    wordViewer.setWords(words);<br />}</pre></code><br /><br />There's a lot going on in this one method. We should know scary things are happening when we have a method that takes no parameters and returns nothing. We are directly interacting with both a GUI and a database. We are grabbing those instances from global state. We're embedding an SQL query in the middle of this code. We are reaching down through multiple levels to get the date range. In just a few lines, we have quite the bird's nest.<br /><br />To improve this code, we need to expose the implicit dependencies and make them explicit. The series of refactoring steps results in a series of progressively more explicit methods:<br /><br /><code><pre>/**<br /> * Show words and their counts imported between the dates specified.<br /> *<br /> * Step 0: The original method signature, left deprecated to allow<br /> *     client code to still compile<br /> * @deprecated Use {@link #showWordCountsInRange(JWordViewer, Database)}<br /> */<br />@Deprecated<br />public void showWordCountsInRange() {<br />    showWordCountsInRange(App.getGUI().getActiveWordViewer(), App.getDB());<br />}<br /><br />/**<br /> * Show words and their counts imported between the dates specified.<br /> *<br /> * Step 1: Directly inject the global dependencies as method parameters<br /> * @see #getWordCountsInRange(JWordViewer, Database)<br /> */<br />public void showWordCountsInRange(JWordViewer wordViewer, Database db) {<br />    wordViewer.setWords(getWordCountsInRange(wordViewer, db));<br />}<br /><br />/**<br /> * Get words and their counts imported between the dates specified.<br /> *<br /> * Step 2: Return a value instead of setting on a parameter<br /> * @deprecated Use getWordCountsInRange(Date, Date, Database)<br /> */<br />@Deprecated<br />public Map&lt;String, Long&gt; getWordCountsInRange(JWordViewer wordViewer, Database db) {<br />    return getWordCountsInRange(<br />        wordViewer.getStartField().getDate(), wordViewer.getEndField().getDate(),<br />        db);<br />}<br /><br />/**<br /> * Get words and their counts imported between the dates specified.<br /> *<br /> * Step 3: Pass the dates rather than the GUI element holding them<br /> */<br />public Map&lt;String, Long&gt; getWordCountsInRange(Date startDate, Date endDate, Database db) {<br />    ResultSet rs = db.query("SELECT word, COUNT(word) AS word_count FROM Words WHERE " +<br />        "import_date &gt;= " + DBUtils.toSQLString(startDate) + " AND " +<br />        "import_date &lt; " + DBUtils.toSQLString(endDate) + " " +<br />        "GROUP BY word");<br /><br />    Map<String, Long> words = new HashMap<>();<br /><br />    for(Result result : resultSet) {<br />       words.add(result.getString("word"), result.getLong("word_count"));<br />    }<br /><br />    return words;<br />}</pre></code><br /><br />This refactoring is not complete, but just from this, we can see important changes to the code. In the first step, we take the implicit dependencies of the GUI and the database and inject them as parameters. A method that used to have no parameters now has two parameters. In a way, this is <em>objectively worse</em> because we have <strong>more</strong> parameters now, not less. Calling code will now need to get those dependencies separately and pass them into the new method. The new parameters do not represent new dependencies though. The dependencies were already there, and we are just making them explicit.<br /><br />In step 2, we address the dependency of the output. Instead of outputting to the <code>JWordViewer</code> parameter, we return the mapping. For our calling code, this is also <em>objectively worse</em>. At that point we need to add the word mapping to the GUI element separately. That step is explicit and no longer <em><q>magical.</q></em> But we can also reuse this method to output to a text interface, or to a file, or to anything else. By returning a word-to-count mapping, we allow for that reuse, which also simplifies testing.<br /><br />Step 3 goes back to the input dependencies. Since we no longer output to the <code>JWordViewer</code>, we don't need to take it as a parameter either. We can just take the two dates and go from there. We are free from any GUI. We can get dates from anywhere and return data to anywhere. We've just made the dependency graph simpler without sacrificing any behavior. This change is <em>objectively <strong>better</strong></em>.<br /><br />The resulting improvement is greater than the sum of the improvements of the intermediate steps. Each step added burdens with very little upside, while the original code <em>abstracted</em> getting and showing the word counts. This abstraction was illusory: it merely provided convenience, not encapsulation, reusability, testability, or safety. But what if we had stopped at step 2 or step 1? Calling code would be more verbose, and would need to do more work gathering all these dependencies.<br /><br />In a large, complex restructuring of code, we may make a dozen changes like these, but we can only move one step at a time. We will have a hard time justifying putting a dozen step 1's in the code, potentially forever if we can't make it back. We must be sure to keep the end goal front-and-center. It must be visible, not just to us but to our whole team. Without seeing or understanding the goal, they may use those step 2's in contorted ways that make it <em>more</em> difficult to get to step 3. By keeping focus, things can get better after they get worse.]]></content>
	</entry>
	<entry>
		<id>tag:blogger.com,1999:blog-81864051602136728.post-8608979919560120110</id>
		<title>Inheritance as Polymorphism vs Inheritance as Code Sharing</title>
		<link rel="alternate" type="text/html" href="https://blog.cbojar.net/2016/10/inheritance-as-polymorphism-vs.html"/>
		<published>2016-10-31T11:00:00-04:00</published>
		<updated>2016-10-31T11:00:03-04:00</updated>
		<author>
			<name>cbojar</name>
		</author>
		<content type="html"><![CDATA[We've all heard the mantra that we should favor composition over inheritance, and in most cases this is good advice. Occasionally, though, we really do need an inheritance relationship. Inheritance provides that useful “is-a” relationship that sometimes fits a situation so well. The pitfall we have to watch out for is using inheritance for code sharing between classes that should otherwise not be related, and not for polymorphism, that “is-a” relationship.<br /><br />What makes code sharing through inheritance so bad in the first place? An inheritance relationship is one of the tightest dependencies that could be made between two classes. It is hard-compiled in, and cannot be swapped out at runtime. It's an all-or-nothing relationship, and anything the parent wants to expose, the child must also expose. The child class may be able to override some of the parent behaviors, but the parent may finalize some methods and prevent this, locking the child class in even more tightly. This may be beneficial and desired in the right case, but if an inheritance relationship is shoe-horned in to share code, this can terribly distort the code base.<br /><br />So sharing code through inheritance is bad, but how can we differentiate between inheritance as polymorphism versus inheritance as code sharing. There is a simple smell you can use to tell the difference. If you are driving the instance through the interface of the superclass, it is generally polymorphism; if you are driving the instance through the interface of the subclass, it is generally code sharing. Now this is a heuristic, a code smell, not a hard-and-fast rule, but it should at least point you in the right direction.<br /><br />A few examples, starting with a case of polymorphism:<br /><br /><pre><code><br />public abstract class SalesTaxCalculator {<br />    public abstract double getTaxOn(double price);<br /><br />    public final double getTotalPriceOn(final double price) {<br />        return price + getTaxOn(price);<br />    }<br />}<br /><br />public class DelawareSalesTaxCalculator extends SalesTaxCalculator {<br />    @Override public double getTaxOn(double price) {<br />        return 0.0;<br />    }<br />}<br /><br />public class CaliforniaSalesTaxCalculator extends SalesTaxCalculator {<br />    @Override public double getTaxOn(double price) {<br />        return price * 1.075;<br />    }<br />}<br /><br />public class Main {<br />    public static main(String[] args) {<br />        printPriceAndTaxes(10.0, new DelawareSalesTaxCalculator());<br />        printPriceAndTaxes(10.0, new CaliforniaSalesTaxCalculator());<br />    }<br /><br />    private static void printPriceAndTaxes(double price, SalesTaxCalculator taxCalculator) {<br />        System.out.printf("Price: %.2f%n", price);<br />        System.out.printf("Tax:   %.2f%n", taxCalculator.getTaxOn(price));<br />        System.out.printf("Total: %.2f%n", taxCalculator.getTotalPriceOn(price));<br />    }<br />}<br /></code></pre><br />The code above uses the subclasses according to the interface of the superclass (an example of the <a href="https://sourcemaking.com/design_patterns/strategy" target="_blank">strategy pattern</a>). This is pretty easy to see here since the subclasses don't have any additional behavior. It's even more obvious because in the <code>printPriceAndTaxes</code> method, the <code>taxCalculator</code> is typed to <code>SalesTaxCalculator</code>, though this is not strictly necessary.<br /><br />Now an example of code sharing:<br /><br /><pre><code><br />public abstract class Bird {<br />    public String fly() {<br />        return "Flap flap flutter";<br />    }<br /><br />    public abstract String tweet();<br />}<br /><br />public class Parrot extends Bird {<br />    public boolean caged = false;<br /><br />    public Parrot(boolean caged) {<br />        this.caged = caged;<br />    }<br /><br />    @Override public String fly() {<br />        if (caged) {<br />            throw new CannotFlyException("A caged parrot cannot fly away...");<br />        }<br /><br />        return super.fly();<br />    }<br /><br />    @Override public String tweet() {<br />        return talk("Polly wanna cracker!");<br />    }<br /><br />    public String talk(String say) {<br />        return "Squawk! " + say;<br />    }<br />}<br /><br />public class Penguin extends Bird {<br />    @Override public String fly() {<br />        throw new CannotFlyException("A penguin cannot fly away...");<br />    }<br /><br />    public String swim() {<br />        return "Splash!";<br />    }<br /><br />    @Override public String tweet() {<br />        return "Ahh!";<br />    }<br />}<br /><br />public class Main {<br />    public static main(String[] args) {<br />        Collection<Bird> birds = Arrays.asList(<br />            new Parrot(false), new Parrot(true), new Penguin());<br /><br />        for(Bird bird : birds) {<br />            try {<br />                System.out.println(bird.fly());<br />            } catch(CannotFlyException ex) {<br />                if(bird instanceof Penguin) {<br />                    System.out.println(((Penguin)bird).swim());<br />                } else {<br />                    System.out.println(ex.getMessage());<br />                }<br />            }<br /><br />            System.out.println(bird.tweet());<br /><br />            if(bird instanceof Parrot) {<br />                System.out.println(((Parrot)bird).talk("Polly want a cookie"));<br />            }<br />        }<br />    }<br />}<br /></code></pre><br />Here the fact that we are just sharing code is pretty obvious for many reasons. The use of <code>instanceof</code> tells us that we are more interested in the subclasses than we are of the superclass, even though we are storing each as an instance of the superclass. We can also see this by the fact that we are using only some of the behavior of the superclass. <code>Parrot</code> uses the parent <code>fly</code> method conditionally, and <code>Penguin</code> does not use it at all. The shared code is the <code>fly</code> method (partially), and the type that allows these disparate instances to be grouped together.<br /><br />By breaking inheritance as code sharing relationships by using other tools such as composition and extracting classes to achieve single responsibility, we can get code that is more flexible and much easier to maintain.]]></content>
	</entry>
</feed>
